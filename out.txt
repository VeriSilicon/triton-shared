-- Testing: 215 tests, 8 workers --
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_for_expand_ptr.mlir (1 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_splat_2d.mlir (2 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_for_used_before_update.mlir (3 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/masked_ldst_1d.mlir (4 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/tensor_indices_loop_iterarg_with_masks.mlir (5 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_for_more_init_args.mlir (6 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/kernel-03-matrix-multiplication.mlir (7 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/masked_ldst_sitofp_other.mlir (8 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_mul_value_const.mlir (9 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/convert_tensor_reshape.mlir (10 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_dim1.mlir (11 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_for_used_after_update.mlir (12 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_nested.mlir (13 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_for_accumulation.mlir (14 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/kernel-02-fused-softmax.mlir (15 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_for.mlir (16 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_for.mlir' FAILED ********************
Exit Code: 1

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for.mlir
module {
  tt.func @kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: i32, %arg3: i32, %arg4: i32) {
    %c0_i64 = arith.constant 0 : i64
    %cst = arith.constant dense<0.000000e+00> : tensor<1024xf32>
    %c3 = arith.constant 3 : index
    %c12 = arith.constant 12 : index
    %c0 = arith.constant 0 : index
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %arg2 : i32
    %2 = arith.index_cast %1 : i32 to index
    %3 = arith.extsi %1 : i32 to i64
    %4 = arith.addi %c0_i64, %3 : i64
    %5:3 = scf.for %arg5 = %c0 to %c12 step %c3 iter_args(%arg6 = %4, %arg7 = %2, %arg8 = %cst) -> (i64, index, tensor<1024xf32>) {
      %9 = tts.make_tptr %arg1 to sizes: [1024], strides: [1], offsets: [%arg7], shape: [0], order: [] : <f32> to tensor<1024x!tt.ptr<f32>>
      %10 = "tts.load"(%9) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<1024x!tt.ptr<f32>>) -> tensor<1024xf32>
      %11 = math.exp %10 : tensor<1024xf32>
      %12 = arith.addf %arg8, %11 : tensor<1024xf32>
      %13 = arith.index_cast %arg5 : index to i32
      %14 = arith.addi %arg7, %arg5 : index
      %15 = arith.extsi %13 : i32 to i64
      %16 = arith.addi %arg6, %15 : i64
      scf.yield %16, %14, %12 : i64, index, tensor<1024xf32>
    }
    %6 = arith.muli %0, %arg3 : i32
    %7 = arith.index_cast %6 : i32 to index
    %8 = tts.make_tptr %arg0 to sizes: [1024], strides: [1], offsets: [%7], shape: [0], order: [] : <f32> to tensor<1024x!tt.ptr<f32>>
    "tts.store"(%8, %5#2) <{static_mask_dims = array<i64>}> : (tensor<1024x!tt.ptr<f32>>, tensor<1024xf32>) -> ()
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 1
ok case
%1 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for.mlir:50:11: error: CHECK: expected string not found in input
// CHECK: [[VAR_reinterpret_cast_:%.+]] = memref.reinterpret_cast [[PARAM_1_]] to offset: {{.}}[[VAR_3_]]{{.}}, sizes: [1], strides: [1] : memref<*xf32> to memref<1xf32, strided<[1], offset: ?>>
          ^
<stdin>:11:41: note: scanning from here
 %3 = arith.index_cast %2 : i32 to index
                                        ^
<stdin>:11:41: note: with "PARAM_1_" equal to "%arg1"
 %3 = arith.index_cast %2 : i32 to index
                                        ^
<stdin>:11:41: note: with "VAR_3_" equal to "%3"
 %3 = arith.index_cast %2 : i32 to index
                                        ^
<stdin>:36:18: note: possible intended match here
 %reinterpret_cast = memref.reinterpret_cast %arg0 to offset: [%7], sizes: [1024], strides: [1] : memref<*xf32> to memref<1024xf32, strided<[1], offset: ?>>
                 ^

Input file: <stdin>
Check file: /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for.mlir

-dump-input=help explains the following input dump.

Input was:
<<<<<<
            .
            .
            .
            6:  %c3 = arith.constant 3 : index 
            7:  %cst = arith.constant 0.000000e+00 : f32 
            8:  %0 = tensor.empty() : tensor<1024xf32> 
            9:  %1 = linalg.fill ins(%cst : f32) outs(%0 : tensor<1024xf32>) -> tensor<1024xf32> 
           10:  %2 = arith.muli %arg8, %arg2 : i32 
           11:  %3 = arith.index_cast %2 : i32 to index 
check:50'0                                             X error: no match found
check:50'1                                               with "PARAM_1_" equal to "%arg1"
check:50'2                                               with "VAR_3_" equal to "%3"
           12:  %4 = arith.extsi %2 : i32 to i64 
check:50'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           13:  %5:3 = scf.for %arg11 = %c0 to %c12 step %c3 iter_args(%arg12 = %4, %arg13 = %3, %arg14 = %1) -> (i64, index, tensor<1024xf32>) { 
check:50'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           14:  %reinterpret_cast_0 = memref.reinterpret_cast %arg1 to offset: [%arg13], sizes: [1024], strides: [1] : memref<*xf32> to memref<1024xf32, strided<[1], offset: ?>> 
check:50'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           15:  %alloc = memref.alloc() : memref<1024xf32> 
check:50'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           16:  memref.copy %reinterpret_cast_0, %alloc : memref<1024xf32, strided<[1], offset: ?>> to memref<1024xf32> 
check:50'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            .
            .
            .
           31:  %14 = arith.addi %arg12, %13 : i64 
check:50'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           32:  scf.yield %14, %12, %10 : i64, index, tensor<1024xf32> 
check:50'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           33:  } 
check:50'0     ~~~
           34:  %6 = arith.muli %arg8, %arg3 : i32 
check:50'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           35:  %7 = arith.index_cast %6 : i32 to index 
check:50'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           36:  %reinterpret_cast = memref.reinterpret_cast %arg0 to offset: [%7], sizes: [1024], strides: [1] : memref<*xf32> to memref<1024xf32, strided<[1], offset: ?>> 
check:50'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check:50'3                      ?                                                                                                                                            possible intended match
           37:  bufferization.materialize_in_destination %5#2 in writable %reinterpret_cast : (tensor<1024xf32>, memref<1024xf32, strided<[1], offset: ?>>) -> () 
check:50'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           38:  return 
check:50'0     ~~~~~~~~
           39:  } 
check:50'0     ~~~
           40: } 
check:50'0     ~~
           41:  
check:50'0     ~
>>>>>>

--

********************
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/bitcast.mlir (17 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/kernel-05-layer-norm-dwdb.mlir (18 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/use_mid_chain.mlir (19 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/use_dot_opc.mlir (20 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_add_value.mlir (21 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/block_ptr_advance.mlir (22 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/arith_not_ptr_arith.mlir (23 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_for_2d.mlir (24 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_for_2d.mlir' FAILED ********************
Exit Code: 1

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for_2d.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for_2d.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for_2d.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for_2d.mlir
module {
  tt.func @kernel(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: i32, %arg3: i32, %arg4: i32) {
    %c0_i64 = arith.constant 0 : i64
    %c128 = arith.constant 128 : index
    %cst = arith.constant dense<0.000000e+00> : tensor<128x128xf32>
    %c3 = arith.constant 3 : index
    %c12 = arith.constant 12 : index
    %c0 = arith.constant 0 : index
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %arg2 : i32
    %2 = arith.index_cast %1 : i32 to index
    %3 = arith.extsi %1 : i32 to i64
    %4 = arith.addi %c0_i64, %3 : i64
    %5:3 = scf.for %arg5 = %c0 to %c12 step %c3 iter_args(%arg6 = %cst, %arg7 = %4, %arg8 = %2) -> (tensor<128x128xf32>, i64, index) {
      %10 = arith.addi %arg8, %c128 : index
      %11 = tts.make_tptr %arg1 to sizes: [128, 128], strides: [1, 1], offsets: [%10, 0], shape: [0, 0], order: [] : <f32> to tensor<128x128x!tt.ptr<f32>>
      %12 = "tts.load"(%11) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<128x128x!tt.ptr<f32>>) -> tensor<128x128xf32>
      %13 = math.exp %12 : tensor<128x128xf32>
      %14 = arith.addf %arg6, %13 : tensor<128x128xf32>
      %15 = arith.index_cast %arg5 : index to i32
      %16 = arith.addi %arg8, %arg5 : index
      %17 = arith.extsi %15 : i32 to i64
      %18 = arith.addi %arg7, %17 : i64
      scf.yield %14, %18, %16 : tensor<128x128xf32>, i64, index
    }
    %6 = arith.muli %0, %arg3 : i32
    %7 = arith.index_cast %6 : i32 to index
    %8 = arith.addi %7, %c128 : index
    %9 = tts.make_tptr %arg0 to sizes: [128, 128], strides: [1, 1], offsets: [%8, 0], shape: [0, 0], order: [] : <f32> to tensor<128x128x!tt.ptr<f32>>
    "tts.store"(%9, %5#0) <{static_mask_dims = array<i64>}> : (tensor<128x128x!tt.ptr<f32>>, tensor<128x128xf32>) -> ()
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 1
ok case
%1 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for_2d.mlir:70:11: error: CHECK: expected string not found in input
// CHECK: [[VAR_reinterpret_cast_:%.+]] = memref.reinterpret_cast [[PARAM_1_]] to offset: {{.}}[[VAR_3_]]{{.}}, sizes: [1], strides: [1] : memref<*xf32> to memref<1xf32, strided<[1], offset: ?>>
          ^
<stdin>:12:41: note: scanning from here
 %3 = arith.index_cast %2 : i32 to index
                                        ^
<stdin>:12:41: note: with "PARAM_1_" equal to "%arg1"
 %3 = arith.index_cast %2 : i32 to index
                                        ^
<stdin>:12:41: note: with "VAR_3_" equal to "%3"
 %3 = arith.index_cast %2 : i32 to index
                                        ^
<stdin>:16:18: note: possible intended match here
 %reinterpret_cast_0 = memref.reinterpret_cast %arg1 to offset: [%9], sizes: [128, 128], strides: [1, 1] : memref<*xf32> to memref<128x128xf32, strided<[1, 1], offset: ?>>
                 ^

Input file: <stdin>
Check file: /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_for_2d.mlir

-dump-input=help explains the following input dump.

Input was:
<<<<<<
            .
            .
            .
            7:  %c3 = arith.constant 3 : index 
            8:  %cst = arith.constant 0.000000e+00 : f32 
            9:  %0 = tensor.empty() : tensor<128x128xf32> 
           10:  %1 = linalg.fill ins(%cst : f32) outs(%0 : tensor<128x128xf32>) -> tensor<128x128xf32> 
           11:  %2 = arith.muli %arg8, %arg2 : i32 
           12:  %3 = arith.index_cast %2 : i32 to index 
check:70'0                                             X error: no match found
check:70'1                                               with "PARAM_1_" equal to "%arg1"
check:70'2                                               with "VAR_3_" equal to "%3"
           13:  %4 = arith.extsi %2 : i32 to i64 
check:70'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           14:  %5:3 = scf.for %arg11 = %c0 to %c12 step %c3 iter_args(%arg12 = %1, %arg13 = %4, %arg14 = %3) -> (tensor<128x128xf32>, i64, index) { 
check:70'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           15:  %9 = arith.addi %arg14, %c128 : index 
check:70'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           16:  %reinterpret_cast_0 = memref.reinterpret_cast %arg1 to offset: [%9], sizes: [128, 128], strides: [1, 1] : memref<*xf32> to memref<128x128xf32, strided<[1, 1], offset: ?>> 
check:70'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
check:70'3                      ?                                                                                                                                                           possible intended match
           17:  %alloc = memref.alloc() : memref<128x128xf32> 
check:70'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           18:  memref.copy %reinterpret_cast_0, %alloc : memref<128x128xf32, strided<[1, 1], offset: ?>> to memref<128x128xf32> 
check:70'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           19:  %10 = bufferization.to_tensor %alloc restrict writable : memref<128x128xf32> 
check:70'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           20:  %11 = linalg.generic {indexing_maps = [#map, #map], iterator_types = ["parallel", "parallel"]} ins(%10 : tensor<128x128xf32>) outs(%10 : tensor<128x128xf32>) { 
check:70'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           21:  ^bb0(%in: f32, %out: f32): 
check:70'0     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            .
            .
            .
>>>>>>

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/reducesum_scalar.mlir (25 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/reducesum_scalar.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir:1 offset :14:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %res, %3 : !tt.ptr<bf16>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir:1 offset :14:5: note: see current operation: tt.store %arg1, %5 : !tt.ptr<bf16>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir:1 offset :14:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %res, %3 : !tt.ptr<bf16>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir:1 offset :14:5: note: see current operation: tt.store %arg1, %5 : !tt.ptr<bf16>
module {
  tt.func @kernel(%arg0: !tt.ptr<bf16>, %arg1: !tt.ptr<bf16>) {
    %0 = tts.make_tptr %arg0 to sizes: [128], strides: [1], offsets: [0], shape: [0], order: [] : <bf16> to tensor<128x!tt.ptr<bf16>>
    %1 = "tts.load"(%0) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<128x!tt.ptr<bf16>>) -> tensor<128xbf16>
    %2 = "tt.reduce"(%1) <{axis = 0 : i32}> ({
    ^bb0(%arg2: bf16, %arg3: bf16):
      %3 = arith.addf %arg2, %arg3 : bf16
      tt.reduce.return %3 : bf16
    }) : (tensor<128xbf16>) -> bf16
    tt.store %arg1, %2 : !tt.ptr<bf16>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xbf16> to !tt.ptr<bf16>
<block argument> of type 'memref<*xbf16>' at index: 1
ok case
%1 = unrealized_conversion_cast %arg0 : memref<*xbf16> to !tt.ptr<bf16>
<block argument> of type 'memref<*xbf16>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir:1 offset :3:44: error: failed to legalize unresolved materialization from ('memref<*xbf16>') to '!tt.ptr<bf16>' that remained live after conversion
  tt.func @kernel(%afloat : !tt.ptr<bf16>, %res : !tt.ptr<bf16>)
                                           ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir:1 offset :3:44: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg1) : (memref<*xbf16>) -> !tt.ptr<bf16>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir:1 offset :3:3: note: see existing live user here: %1 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<bf16>, i64) -> !tt.ptr<bf16>
  tt.func @kernel(%afloat : !tt.ptr<bf16>, %res : !tt.ptr<bf16>)
  ^
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_scalar.mlir

--

********************
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/convert_argmin_argmax_2d.mlir (26 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_mul_const_const.mlir (27 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/tensor_indices_loop_iterargs_nested.mlir (28 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/reducesum_512_256_f32_axis1.mlir (29 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_nested.mlir (30 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/block_ptr_complex_offset.mlir (31 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/block_ptr_complex_offset.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --structured-to-memref --split-input-file /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/block_ptr_complex_offset.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/block_ptr_complex_offset.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/block_ptr_complex_offset.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --structured-to-memref --split-input-file /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/block_ptr_complex_offset.mlir
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xbf16> to !tt.ptr<bf16>
<block argument> of type 'memref<*xbf16>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/block_ptr_complex_offset.mlir:1 offset :4:41: error: failed to legalize unresolved materialization from ('memref<*xbf16>') to '!tt.ptr<bf16>' that remained live after conversion
  func.func @fused_attention_fwd_kernel(%arg0: !tt.ptr<bf16>, %arg1: !tt.ptr<bf16>, %arg2: i64, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32) -> tensor<128x128xbf16> {
                                        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/block_ptr_complex_offset.mlir:1 offset :4:41: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xbf16>) -> !tt.ptr<bf16>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/block_ptr_complex_offset.mlir:1 offset :11:10: note: see existing live user here: %7 = "tt.addptr"(%0, %6) : (!tt.ptr<bf16>, i64) -> !tt.ptr<bf16>
    %3 = tt.addptr %arg0, %2 : !tt.ptr<bf16>, i64
         ^
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/block_ptr_complex_offset.mlir

--

********************
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/dot.mlir (32 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/reducesum_512_256_bf16_axis0.mlir (33 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/reducesum_512_256_f32_axis0.mlir (34 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/kernel-01-vector-add.mlir (35 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_reshape_broadcast.mlir (36 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/reducesum_512_256_bf16_axis1.mlir (37 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_loopback.mlir (38 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/masked_ldst_2d.mlir (39 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/cumsum.mlir (40 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/use_end_chain.mlir (41 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/unsupported_extern_elementwise.mlir (42 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir (43 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :38:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %save0, %5 : tensor<128x128x!tt.ptr<bf16>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :38:5: note: see current operation: tt.store %arg3, %19 : tensor<128x128x!tt.ptr<bf16>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :38:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %save0, %5 : tensor<128x128x!tt.ptr<bf16>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :38:5: note: see current operation: tt.store %arg3, %19 : tensor<128x128x!tt.ptr<bf16>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :39:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %save1, %6 : tensor<128x128x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :39:5: note: see current operation: tt.store %arg4, %20 : tensor<128x128x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :39:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %save1, %6 : tensor<128x128x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :39:5: note: see current operation: tt.store %arg4, %20 : tensor<128x128x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :40:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %save2, %7 : tensor<128x128x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :40:5: note: see current operation: tt.store %arg5, %21 : tensor<128x128x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :40:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %save2, %7 : tensor<128x128x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :40:5: note: see current operation: tt.store %arg5, %21 : tensor<128x128x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :41:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %save3, %10 : tensor<128x128x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :41:5: note: see current operation: tt.store %arg6, %22 : tensor<128x128x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :41:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %save3, %10 : tensor<128x128x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :41:5: note: see current operation: tt.store %arg6, %22 : tensor<128x128x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :42:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %save4, %11 : tensor<128x128x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :42:5: note: see current operation: tt.store %arg7, %23 : tensor<128x128x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :42:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %save4, %11 : tensor<128x128x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir:1 offset :42:5: note: see current operation: tt.store %arg7, %23 : tensor<128x128x!tt.ptr<f32>>
module {
  tt.func @kernel(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<i32>, %arg2: !tt.ptr<f16>, %arg3: tensor<128x128x!tt.ptr<bf16>>, %arg4: tensor<128x128x!tt.ptr<f32>>, %arg5: tensor<128x128x!tt.ptr<f32>>, %arg6: tensor<128x128x!tt.ptr<f32>>, %arg7: tensor<128x128x!tt.ptr<f32>>) {
    %0 = tts.make_tptr %arg0 to sizes: [128, 128], strides: [1, 1], offsets: [0, 0], shape: [0, 0], order: [] : <f32> to tensor<128x128x!tt.ptr<f32>>
    %1 = tts.make_tptr %arg1 to sizes: [128, 128], strides: [1, 1], offsets: [0, 0], shape: [0, 0], order: [] : <i32> to tensor<128x128x!tt.ptr<i32>>
    %2 = tts.make_tptr %arg2 to sizes: [128, 128], strides: [1, 1], offsets: [0, 0], shape: [0, 0], order: [] : <f16> to tensor<128x128x!tt.ptr<f16>>
    %3 = "tts.load"(%0) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<128x128x!tt.ptr<f32>>) -> tensor<128x128xf32>
    %4 = "tts.load"(%1) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<128x128x!tt.ptr<i32>>) -> tensor<128x128xi32>
    %5 = "tts.load"(%2) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<128x128x!tt.ptr<f16>>) -> tensor<128x128xf16>
    %6 = arith.truncf %3 : tensor<128x128xf32> to tensor<128x128xbf16>
    %7 = math.exp %3 : tensor<128x128xf32>
    %8 = arith.sitofp %4 : tensor<128x128xi32> to tensor<128x128xf32>
    %9 = arith.extf %5 : tensor<128x128xf16> to tensor<128x128xf32>
    %10 = math.sqrt %3 : tensor<128x128xf32>
    tt.store %arg3, %6 : tensor<128x128x!tt.ptr<bf16>>
    tt.store %arg4, %7 : tensor<128x128x!tt.ptr<f32>>
    tt.store %arg5, %8 : tensor<128x128x!tt.ptr<f32>>
    tt.store %arg6, %9 : tensor<128x128x!tt.ptr<f32>>
    tt.store %arg7, %10 : tensor<128x128x!tt.ptr<f32>>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg2 : memref<*xf16> to !tt.ptr<f16>
<block argument> of type 'memref<*xf16>' at index: 2
ok case
%1 = unrealized_conversion_cast %arg1 : memref<*xi32> to !tt.ptr<i32>
<block argument> of type 'memref<*xi32>' at index: 1
ok case
%2 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir
 #0 0x0000558c3affe8c7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255c8c7)
 #1 0x0000558c3affc3ee llvm::sys::RunSignalHandlers() (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255a3ee)
 #2 0x0000558c3affef7f SignalHandler(int) Signals.cpp:0:0
 #3 0x00007f7ab523d420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)
 #4 0x0000558c390475d4 mlir::Operation::getResults() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:411:12
 #5 0x0000558c390475d4 mlir::Operation::getResultTypes() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:423:47
 #6 0x0000558c390475d4 (anonymous namespace)::StoreOpConverter::matchAndRewrite(mlir::triton::StoreOp, mlir::triton::StoreOpAdaptor, mlir::ConversionPatternRewriter&) const /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:306:24
 #7 0x0000558c38f6281f mlir::OpConversionPattern<mlir::triton::StoreOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/Transforms/DialectConversion.h:545:3
 #8 0x0000558c3ac0e7c0 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c7c0)
 #9 0x0000558c3ac535eb mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_2::operator()() const PatternApplicator.cpp:0:0
#10 0x0000558c3ac5016f mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21ae16f)
#11 0x0000558c3ac0f751 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0
#12 0x0000558c3ac0e864 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c864)
#13 0x0000558c3ac0fc6f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216dc6f)
#14 0x0000558c3ac163ab mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21743ab)
#15 0x0000558c39045d9d (anonymous namespace)::TritonLoadStoreToMemrefPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:410:16
#16 0x0000558c3a569336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#17 0x0000558c3a569ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#18 0x0000558c3a56e02f llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (mlir::OpPassManager&, mlir::Operation*)>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_6>(long, mlir::OpPassManager&, mlir::Operation*) Pass.cpp:0:0
#19 0x0000558c39023ac5 llvm::LogicalResult::failed() const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:43:43
#20 0x0000558c39023ac5 llvm::failed(llvm::LogicalResult) /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:71:58
#21 0x0000558c39023ac5 (anonymous namespace)::TritonToLinalgExperimentalPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonToLinalgExperimental/TritonToLinalgExperimentalPass.cpp:63:9
#22 0x0000558c3a569336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#23 0x0000558c3a569ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#24 0x0000558c3a56bf95 mlir::PassManager::run(mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac9f95)
#25 0x0000558c3a56566f performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0
#26 0x0000558c3a56529d llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_2>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0
#27 0x0000558c3af91f74 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef)::$_0::operator()(llvm::StringRef) const ToolUtilities.cpp:0:0
#28 0x0000558c3af91b50 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x24efb50)
#29 0x0000558c3a5600c1 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe0c1)
#30 0x0000558c3a560373 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe373)
#31 0x0000558c3a560746 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe746)
#32 0x0000558c39071d9b main /home/nhat/github/triton_shared/tools/triton-shared-opt/triton-shared-opt.cpp:16:33
#33 0x00007f7ab4ce1083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3
#34 0x0000558c38d3492e _start (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x29292e)
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir

--

********************
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_broadcast.mlir (44 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_argmin_argmax.mlir (45 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_argmin_argmax.mlir' FAILED ********************
Exit Code: 1

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental  /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:1 offset :25:5: remark: PtrAnalysis: scalar storeOp will not be rewritten
    tt.store %9, %8#1 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:1 offset :25:5: note: see current operation: tt.store %12, %11#1 : !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:1 offset :25:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %9, %8#1 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:1 offset :25:5: note: see current operation: tt.store %12, %11#1 : !tt.ptr<i32>
%10 = unrealized_conversion_cast %9 : i64 to !tt.ptr<i32> {"reconvert-offset-to-ptr"}
module {
  tt.func public @argmax_012(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<i32>, %arg2: i32) {
    %c0_i64 = arith.constant 0 : i64
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %arg2 : i32
    %2 = arith.index_cast %1 : i32 to index
    %3 = tt.make_range {end = 4096 : i32, start = 0 : i32} : tensor<4096xi32>
    %4 = tts.make_tptr %arg0 to sizes: [4096], strides: [1], offsets: [%2], shape: [0], order: [] : <f32> to tensor<4096x!tt.ptr<f32>>
    %5 = "tts.load"(%4) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<4096x!tt.ptr<f32>>) -> tensor<4096xf32>
    %6:2 = "tt.reduce"(%5, %3) <{axis = 0 : i32}> ({
    ^bb0(%arg3: f32, %arg4: i32, %arg5: f32, %arg6: i32):
      %11 = arith.cmpf oeq, %arg3, %arg5 : f32
      %12 = arith.cmpi slt, %arg4, %arg6 : i32
      %13 = arith.andi %11, %12 : i1
      %14 = arith.cmpf ogt, %arg3, %arg5 : f32
      %15 = arith.ori %14, %13 : i1
      %16 = arith.select %15, %arg3, %arg5 : f32
      %17 = arith.select %15, %arg4, %arg6 : i32
      tt.reduce.return %16, %17 : f32, i32
    }) : (tensor<4096xf32>, tensor<4096xi32>) -> (f32, i32)
    %7 = arith.extsi %0 : i32 to i64
    %8 = arith.addi %c0_i64, %7 : i64
    %9 = "tts.create_ptr"(%arg1, %8) : (!tt.ptr<i32>, i64) -> !tt.ptr<i32>
    %10 = builtin.unrealized_conversion_cast %8 : i64 to !tt.ptr<i32> {"reconvert-offset-to-ptr"}
    tt.store %9, %6#1 : !tt.ptr<i32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xi32> to !tt.ptr<i32>
<block argument> of type 'memref<*xi32>' at index: 1
ok case
%1 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:1 offset :4:51: error: failed to legalize unresolved materialization from ('memref<*xi32>') to '!tt.ptr<i32>' that remained live after conversion
  tt.func public @argmax_012(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<i32>, %arg2: i32) {
                                                  ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:1 offset :4:51: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg1) : (memref<*xi32>) -> !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:1 offset :24:10: note: see existing live user here: %11 = "tts.create_ptr"(%0, %10) : (!tt.ptr<i32>, i64) -> !tt.ptr<i32>
    %9 = tt.addptr %arg1, %0 : !tt.ptr<i32>, i32
         ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:73 offset :25:5: remark: PtrAnalysis: scalar storeOp will not be rewritten
    tt.store %9, %8#1 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:73 offset :25:5: note: see current operation: tt.store %12, %11#1 : !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:73 offset :25:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %9, %8#1 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:73 offset :25:5: note: see current operation: tt.store %12, %11#1 : !tt.ptr<i32>
%10 = unrealized_conversion_cast %9 : i64 to !tt.ptr<i32> {"reconvert-offset-to-ptr"}
module {
  tt.func public @argmin_012(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<i32>, %arg2: i32) {
    %c0_i64 = arith.constant 0 : i64
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %arg2 : i32
    %2 = arith.index_cast %1 : i32 to index
    %3 = tt.make_range {end = 4096 : i32, start = 0 : i32} : tensor<4096xi32>
    %4 = tts.make_tptr %arg0 to sizes: [4096], strides: [1], offsets: [%2], shape: [0], order: [] : <f32> to tensor<4096x!tt.ptr<f32>>
    %5 = "tts.load"(%4) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<4096x!tt.ptr<f32>>) -> tensor<4096xf32>
    %6:2 = "tt.reduce"(%5, %3) <{axis = 0 : i32}> ({
    ^bb0(%arg3: f32, %arg4: i32, %arg5: f32, %arg6: i32):
      %11 = arith.cmpf oeq, %arg3, %arg5 : f32
      %12 = arith.cmpi slt, %arg4, %arg6 : i32
      %13 = arith.andi %11, %12 : i1
      %14 = arith.cmpf olt, %arg3, %arg5 : f32
      %15 = arith.ori %14, %13 : i1
      %16 = arith.select %15, %arg3, %arg5 : f32
      %17 = arith.select %15, %arg4, %arg6 : i32
      tt.reduce.return %16, %17 : f32, i32
    }) : (tensor<4096xf32>, tensor<4096xi32>) -> (f32, i32)
    %7 = arith.extsi %0 : i32 to i64
    %8 = arith.addi %c0_i64, %7 : i64
    %9 = "tts.create_ptr"(%arg1, %8) : (!tt.ptr<i32>, i64) -> !tt.ptr<i32>
    %10 = builtin.unrealized_conversion_cast %8 : i64 to !tt.ptr<i32> {"reconvert-offset-to-ptr"}
    tt.store %9, %6#1 : !tt.ptr<i32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xi32> to !tt.ptr<i32>
<block argument> of type 'memref<*xi32>' at index: 1
ok case
%1 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:73 offset :4:51: error: failed to legalize unresolved materialization from ('memref<*xi32>') to '!tt.ptr<i32>' that remained live after conversion
  tt.func public @argmin_012(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<i32>, %arg2: i32) {
                                                  ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:73 offset :4:51: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg1) : (memref<*xi32>) -> !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:73 offset :24:10: note: see existing live user here: %11 = "tts.create_ptr"(%0, %10) : (!tt.ptr<i32>, i64) -> !tt.ptr<i32>
    %9 = tt.addptr %arg1, %0 : !tt.ptr<i32>, i32
         ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir:31:17: error: CHECK-LABEL: expected string not found in input
// CHECK-LABEL: func.func @argmax_012
                ^
<stdin>:1:1: note: scanning from here
// -----
^

Input file: <stdin>
Check file: /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_argmin_argmax.mlir

-dump-input=help explains the following input dump.

Input was:
<<<<<<
          1: // ----- 
label:31     X~~~~~~~~ error: no match found
>>>>>>

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_splat_float.mlir (46 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_splat_float.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir:1 offset :9:9: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
        tt.store %save0, %0 : tensor<1024x!tt.ptr<f32>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir:1 offset :9:9: note: see current operation: tt.store %arg2, %0 : tensor<1024x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir:1 offset :9:9: remark: PtrAnalysis: Failed to rewrite StoreOp
        tt.store %save0, %0 : tensor<1024x!tt.ptr<f32>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir:1 offset :9:9: note: see current operation: tt.store %arg2, %0 : tensor<1024x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir:1 offset :10:9: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
        tt.store %save1, %1 : tensor<128x256x!tt.ptr<bf16>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir:1 offset :10:9: note: see current operation: tt.store %arg3, %1 : tensor<128x256x!tt.ptr<bf16>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir:1 offset :10:9: remark: PtrAnalysis: Failed to rewrite StoreOp
        tt.store %save1, %1 : tensor<128x256x!tt.ptr<bf16>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir:1 offset :10:9: note: see current operation: tt.store %arg3, %1 : tensor<128x256x!tt.ptr<bf16>>
module {
  tt.func @kernel(%arg0: f32, %arg1: bf16, %arg2: tensor<1024x!tt.ptr<f32>>, %arg3: tensor<128x256x!tt.ptr<bf16>>) {
    %0 = tt.splat %arg0 : f32 -> tensor<1024xf32>
    %1 = tt.splat %arg1 : bf16 -> tensor<128x256xbf16>
    tt.store %arg2, %0 : tensor<1024x!tt.ptr<f32>>
    tt.store %arg3, %1 : tensor<128x256x!tt.ptr<bf16>>
    tt.return
  }
}
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir
 #0 0x0000557664bfb8c7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255c8c7)
 #1 0x0000557664bf93ee llvm::sys::RunSignalHandlers() (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255a3ee)
 #2 0x0000557664bfbf7f SignalHandler(int) Signals.cpp:0:0
 #3 0x00007f1bdd2be420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)
 #4 0x0000557662c445d4 mlir::Operation::getResults() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:411:12
 #5 0x0000557662c445d4 mlir::Operation::getResultTypes() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:423:47
 #6 0x0000557662c445d4 (anonymous namespace)::StoreOpConverter::matchAndRewrite(mlir::triton::StoreOp, mlir::triton::StoreOpAdaptor, mlir::ConversionPatternRewriter&) const /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:306:24
 #7 0x0000557662b5f81f mlir::OpConversionPattern<mlir::triton::StoreOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/Transforms/DialectConversion.h:545:3
 #8 0x000055766480b7c0 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c7c0)
 #9 0x00005576648505eb mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_2::operator()() const PatternApplicator.cpp:0:0
#10 0x000055766484d16f mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21ae16f)
#11 0x000055766480c751 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0
#12 0x000055766480b864 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c864)
#13 0x000055766480cc6f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216dc6f)
#14 0x00005576648133ab mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21743ab)
#15 0x0000557662c42d9d (anonymous namespace)::TritonLoadStoreToMemrefPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:410:16
#16 0x0000557664166336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#17 0x0000557664166ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#18 0x000055766416b02f llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (mlir::OpPassManager&, mlir::Operation*)>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_6>(long, mlir::OpPassManager&, mlir::Operation*) Pass.cpp:0:0
#19 0x0000557662c20ac5 llvm::LogicalResult::failed() const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:43:43
#20 0x0000557662c20ac5 llvm::failed(llvm::LogicalResult) /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:71:58
#21 0x0000557662c20ac5 (anonymous namespace)::TritonToLinalgExperimentalPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonToLinalgExperimental/TritonToLinalgExperimentalPass.cpp:63:9
#22 0x0000557664166336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#23 0x0000557664166ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#24 0x0000557664168f95 mlir::PassManager::run(mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac9f95)
#25 0x000055766416266f performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0
#26 0x000055766416229d llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_2>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0
#27 0x0000557664b8ef74 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef)::$_0::operator()(llvm::StringRef) const ToolUtilities.cpp:0:0
#28 0x0000557664b8eb50 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x24efb50)
#29 0x000055766415d0c1 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe0c1)
#30 0x000055766415d373 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe373)
#31 0x000055766415d746 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe746)
#32 0x0000557662c6ed9b main /home/nhat/github/triton_shared/tools/triton-shared-opt/triton-shared-opt.cpp:16:33
#33 0x00007f1bdcd62083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3
#34 0x000055766293192e _start (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x29292e)
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_splat_float.mlir

--

********************
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_2d_example.mlir (47 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir (48 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir:1 offset :59:5: remark: PtrAnalysis: scalar storeOp will not be rewritten
    tt.store %22, %11 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir:1 offset :59:5: note: see current operation: tt.store %24, %13 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir:1 offset :59:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %22, %11 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir:1 offset :59:5: note: see current operation: tt.store %24, %13 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir:1 offset :61:5: remark: PtrAnalysis: scalar storeOp will not be rewritten
    tt.store %23, %21 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir:1 offset :61:5: note: see current operation: tt.store %26, %24 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir:1 offset :61:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %23, %21 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir:1 offset :61:5: note: see current operation: tt.store %26, %24 : !tt.ptr<f32>
%23 = unrealized_conversion_cast %22 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
%20 = unrealized_conversion_cast %19 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
module {
  tt.func public @_layer_norm_fwd_fused_0123456789(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: !tt.ptr<f32>, %arg3: !tt.ptr<f32>, %arg4: !tt.ptr<f32>, %arg5: !tt.ptr<f32>, %arg6: i32, %arg7: i32, %arg8: f32) {
    %c0_i64 = arith.constant 0 : i64
    %c0_i64_0 = arith.constant 0 : i64
    %cst = arith.constant 0.000000e+00 : f32
    %c256 = arith.constant 256 : index
    %cst_1 = arith.constant dense<0.000000e+00> : tensor<256xf32>
    %c256_i32 = arith.constant 256 : i32
    %c0_i32 = arith.constant 0 : i32
    %cst_2 = arith.constant 1.000000e+00 : f32
    %0 = tt.get_program_id x : i32
    %1 = arith.muli %0, %arg6 : i32
    %2 = arith.index_cast %1 : i32 to index
    %3 = tt.make_range {end = 256 : i32, start = 0 : i32} : tensor<256xi32>
    %4 = tt.splat %arg7 : i32 -> tensor<256xi32>
    %5 = scf.for %arg9 = %c0_i32 to %arg7 step %c256_i32 iter_args(%arg10 = %cst_1) -> (tensor<256xf32>)  : i32 {
      %25 = arith.index_cast %arg9 : i32 to index
      %26 = arith.addi %2, %25 : index
      %27 = tts.make_tptr %arg0 to sizes: [256], strides: [1], offsets: [%26], shape: [0], order: [] : <f32> to tensor<256x!tt.ptr<f32>>
      %28 = arith.addi %25, %c256 : index
      %29 = arith.index_cast %arg7 : i32 to index
      %30 = arith.minsi %28, %29 : index
      %31 = arith.subi %30, %25 : index
      %32 = "tts.load"(%27, %31, %cst) <{operandSegmentSizes = array<i32: 1, 1, 1>, static_mask_dims = array<i64: -9223372036854775808>}> : (tensor<256x!tt.ptr<f32>>, index, f32) -> tensor<256xf32>
      %33 = arith.addf %arg10, %32 : tensor<256xf32>
      scf.yield %33 : tensor<256xf32>
    }
    %6 = "tt.reduce"(%5) <{axis = 0 : i32}> ({
    ^bb0(%arg9: f32, %arg10: f32):
      %25 = arith.addf %arg9, %arg10 : f32
      tt.reduce.return %25 : f32
    }) : (tensor<256xf32>) -> f32
    %7 = arith.sitofp %arg7 : i32 to f32
    %8 = arith.divf %6, %7 : f32
    %9 = tt.splat %8 : f32 -> tensor<256xf32>
    %10 = scf.for %arg9 = %c0_i32 to %arg7 step %c256_i32 iter_args(%arg10 = %cst_1) -> (tensor<256xf32>)  : i32 {
      %25 = tt.splat %arg9 : i32 -> tensor<256xi32>
      %26 = arith.addi %25, %3 : tensor<256xi32>
      %27 = arith.cmpi slt, %26, %4 : tensor<256xi32>
      %28 = arith.index_cast %arg9 : i32 to index
      %29 = arith.addi %2, %28 : index
      %30 = tts.make_tptr %arg0 to sizes: [256], strides: [1], offsets: [%29], shape: [0], order: [] : <f32> to tensor<256x!tt.ptr<f32>>
      %31 = arith.addi %28, %c256 : index
      %32 = arith.index_cast %arg7 : i32 to index
      %33 = arith.minsi %31, %32 : index
      %34 = arith.subi %33, %28 : index
      %35 = "tts.load"(%30, %34, %cst) <{operandSegmentSizes = array<i32: 1, 1, 1>, static_mask_dims = array<i64: -9223372036854775808>}> : (tensor<256x!tt.ptr<f32>>, index, f32) -> tensor<256xf32>
      %36 = arith.subf %35, %9 : tensor<256xf32>
      %37 = arith.select %27, %36, %cst_1 : tensor<256xi1>, tensor<256xf32>
      %38 = arith.mulf %37, %37 : tensor<256xf32>
      %39 = arith.addf %arg10, %38 : tensor<256xf32>
      scf.yield %39 : tensor<256xf32>
    }
    %11 = "tt.reduce"(%10) <{axis = 0 : i32}> ({
    ^bb0(%arg9: f32, %arg10: f32):
      %25 = arith.addf %arg9, %arg10 : f32
      tt.reduce.return %25 : f32
    }) : (tensor<256xf32>) -> f32
    %12 = arith.divf %11, %7 : f32
    %13 = arith.addf %12, %arg8 : f32
    %14 = math.sqrt %13 : f32
    %15 = arith.divf %cst_2, %14 : f32
    %16 = arith.extsi %0 : i32 to i64
    %17 = arith.addi %c0_i64_0, %16 : i64
    %18 = "tts.create_ptr"(%arg4, %17) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
    %19 = builtin.unrealized_conversion_cast %17 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
    tt.store %18, %8 : !tt.ptr<f32>
    %20 = arith.extsi %0 : i32 to i64
    %21 = arith.addi %c0_i64, %20 : i64
    %22 = "tts.create_ptr"(%arg5, %21) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
    %23 = builtin.unrealized_conversion_cast %21 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
    tt.store %22, %15 : !tt.ptr<f32>
    %24 = tt.splat %15 : f32 -> tensor<256xf32>
    scf.for %arg9 = %c0_i32 to %arg7 step %c256_i32  : i32 {
      %25 = arith.index_cast %arg9 : i32 to index
      %26 = tts.make_tptr %arg2 to sizes: [256], strides: [1], offsets: [%25], shape: [0], order: [] : <f32> to tensor<256x!tt.ptr<f32>>
      %27 = arith.addi %25, %c256 : index
      %28 = arith.index_cast %arg7 : i32 to index
      %29 = arith.minsi %27, %28 : index
      %30 = arith.subi %29, %25 : index
      %31 = "tts.load"(%26, %30) <{operandSegmentSizes = array<i32: 1, 1, 0>, static_mask_dims = array<i64: -9223372036854775808>}> : (tensor<256x!tt.ptr<f32>>, index) -> tensor<256xf32>
      %32 = tts.make_tptr %arg3 to sizes: [256], strides: [1], offsets: [%25], shape: [0], order: [] : <f32> to tensor<256x!tt.ptr<f32>>
      %33 = "tts.load"(%32, %30) <{operandSegmentSizes = array<i32: 1, 1, 0>, static_mask_dims = array<i64: -9223372036854775808>}> : (tensor<256x!tt.ptr<f32>>, index) -> tensor<256xf32>
      %34 = arith.addi %2, %25 : index
      %35 = tts.make_tptr %arg0 to sizes: [256], strides: [1], offsets: [%34], shape: [0], order: [] : <f32> to tensor<256x!tt.ptr<f32>>
      %36 = "tts.load"(%35, %30, %cst) <{operandSegmentSizes = array<i32: 1, 1, 1>, static_mask_dims = array<i64: -9223372036854775808>}> : (tensor<256x!tt.ptr<f32>>, index, f32) -> tensor<256xf32>
      %37 = arith.subf %36, %9 : tensor<256xf32>
      %38 = arith.mulf %37, %24 : tensor<256xf32>
      %39 = arith.mulf %38, %31 : tensor<256xf32>
      %40 = arith.addf %39, %33 : tensor<256xf32>
      %41 = tts.make_tptr %arg1 to sizes: [256], strides: [1], offsets: [%34], shape: [0], order: [] : <f32> to tensor<256x!tt.ptr<f32>>
      "tts.store"(%41, %40, %30) <{static_mask_dims = array<i64: -9223372036854775808>}> : (tensor<256x!tt.ptr<f32>>, tensor<256xf32>, index) -> ()
    }
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg5 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 5
ok case
%1 = unrealized_conversion_cast %arg4 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 4
ok case
%2 = unrealized_conversion_cast %arg3 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 3
ok case
%3 = unrealized_conversion_cast %arg2 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 2
ok case
%4 = unrealized_conversion_cast %arg1 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 1
ok case
%5 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir:1 offset :4:157: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func public @_layer_norm_fwd_fused_0123456789(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: !tt.ptr<f32>, %arg3: !tt.ptr<f32>, %arg4: !tt.ptr<f32>, %arg5: !tt.ptr<f32>, %arg6: i32, %arg7: i32, %arg8: f32) {
                                                                                                                                                            ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir:1 offset :4:157: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg5) : (memref<*xf32>) -> !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir:1 offset :60:11: note: see existing live user here: %25 = "tts.create_ptr"(%0, %24) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
    %23 = tt.addptr %arg5, %0 : !tt.ptr<f32>, i32
          ^
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir

--

********************
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_splat.mlir (49 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir (50 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :32:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %save0, %5 : tensor<1024x!tt.ptr<bf16>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :32:5: note: see current operation: tt.store %arg3, %13 : tensor<1024x!tt.ptr<bf16>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :32:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %save0, %5 : tensor<1024x!tt.ptr<bf16>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :32:5: note: see current operation: tt.store %arg3, %13 : tensor<1024x!tt.ptr<bf16>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :33:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %save1, %6 : tensor<1024x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :33:5: note: see current operation: tt.store %arg4, %14 : tensor<1024x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :33:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %save1, %6 : tensor<1024x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :33:5: note: see current operation: tt.store %arg4, %14 : tensor<1024x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :34:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %save2, %7 : tensor<1024x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :34:5: note: see current operation: tt.store %arg5, %15 : tensor<1024x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :34:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %save2, %7 : tensor<1024x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :34:5: note: see current operation: tt.store %arg5, %15 : tensor<1024x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :35:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %save3, %10 : tensor<1024x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :35:5: note: see current operation: tt.store %arg6, %16 : tensor<1024x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :35:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %save3, %10 : tensor<1024x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :35:5: note: see current operation: tt.store %arg6, %16 : tensor<1024x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :36:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %save4, %11 : tensor<1024x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :36:5: note: see current operation: tt.store %arg7, %17 : tensor<1024x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :36:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %save4, %11 : tensor<1024x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir:1 offset :36:5: note: see current operation: tt.store %arg7, %17 : tensor<1024x!tt.ptr<f32>>
module {
  tt.func @kernel(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<i32>, %arg2: !tt.ptr<f16>, %arg3: tensor<1024x!tt.ptr<bf16>>, %arg4: tensor<1024x!tt.ptr<f32>>, %arg5: tensor<1024x!tt.ptr<f32>>, %arg6: tensor<1024x!tt.ptr<f32>>, %arg7: tensor<1024x!tt.ptr<f32>>) {
    %0 = tts.make_tptr %arg0 to sizes: [1024], strides: [1], offsets: [0], shape: [0], order: [] : <f32> to tensor<1024x!tt.ptr<f32>>
    %1 = tts.make_tptr %arg1 to sizes: [1024], strides: [1], offsets: [0], shape: [0], order: [] : <i32> to tensor<1024x!tt.ptr<i32>>
    %2 = tts.make_tptr %arg2 to sizes: [1024], strides: [1], offsets: [0], shape: [0], order: [] : <f16> to tensor<1024x!tt.ptr<f16>>
    %3 = "tts.load"(%0) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<1024x!tt.ptr<f32>>) -> tensor<1024xf32>
    %4 = "tts.load"(%1) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<1024x!tt.ptr<i32>>) -> tensor<1024xi32>
    %5 = "tts.load"(%2) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<1024x!tt.ptr<f16>>) -> tensor<1024xf16>
    %6 = arith.truncf %3 : tensor<1024xf32> to tensor<1024xbf16>
    %7 = math.exp %3 : tensor<1024xf32>
    %8 = arith.sitofp %4 : tensor<1024xi32> to tensor<1024xf32>
    %9 = arith.extf %5 : tensor<1024xf16> to tensor<1024xf32>
    %10 = math.sqrt %3 : tensor<1024xf32>
    tt.store %arg3, %6 : tensor<1024x!tt.ptr<bf16>>
    tt.store %arg4, %7 : tensor<1024x!tt.ptr<f32>>
    tt.store %arg5, %8 : tensor<1024x!tt.ptr<f32>>
    tt.store %arg6, %9 : tensor<1024x!tt.ptr<f32>>
    tt.store %arg7, %10 : tensor<1024x!tt.ptr<f32>>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg2 : memref<*xf16> to !tt.ptr<f16>
<block argument> of type 'memref<*xf16>' at index: 2
ok case
%1 = unrealized_conversion_cast %arg1 : memref<*xi32> to !tt.ptr<i32>
<block argument> of type 'memref<*xi32>' at index: 1
ok case
%2 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir
 #0 0x00005647257058c7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255c8c7)
 #1 0x00005647257033ee llvm::sys::RunSignalHandlers() (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255a3ee)
 #2 0x0000564725705f7f SignalHandler(int) Signals.cpp:0:0
 #3 0x00007fbcbaf2f420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)
 #4 0x000056472374e5d4 mlir::Operation::getResults() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:411:12
 #5 0x000056472374e5d4 mlir::Operation::getResultTypes() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:423:47
 #6 0x000056472374e5d4 (anonymous namespace)::StoreOpConverter::matchAndRewrite(mlir::triton::StoreOp, mlir::triton::StoreOpAdaptor, mlir::ConversionPatternRewriter&) const /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:306:24
 #7 0x000056472366981f mlir::OpConversionPattern<mlir::triton::StoreOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/Transforms/DialectConversion.h:545:3
 #8 0x00005647253157c0 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c7c0)
 #9 0x000056472535a5eb mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_2::operator()() const PatternApplicator.cpp:0:0
#10 0x000056472535716f mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21ae16f)
#11 0x0000564725316751 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0
#12 0x0000564725315864 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c864)
#13 0x0000564725316c6f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216dc6f)
#14 0x000056472531d3ab mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21743ab)
#15 0x000056472374cd9d (anonymous namespace)::TritonLoadStoreToMemrefPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:410:16
#16 0x0000564724c70336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#17 0x0000564724c70ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#18 0x0000564724c7502f llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (mlir::OpPassManager&, mlir::Operation*)>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_6>(long, mlir::OpPassManager&, mlir::Operation*) Pass.cpp:0:0
#19 0x000056472372aac5 llvm::LogicalResult::failed() const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:43:43
#20 0x000056472372aac5 llvm::failed(llvm::LogicalResult) /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:71:58
#21 0x000056472372aac5 (anonymous namespace)::TritonToLinalgExperimentalPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonToLinalgExperimental/TritonToLinalgExperimentalPass.cpp:63:9
#22 0x0000564724c70336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#23 0x0000564724c70ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#24 0x0000564724c72f95 mlir::PassManager::run(mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac9f95)
#25 0x0000564724c6c66f performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0
#26 0x0000564724c6c29d llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_2>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0
#27 0x0000564725698f74 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef)::$_0::operator()(llvm::StringRef) const ToolUtilities.cpp:0:0
#28 0x0000564725698b50 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x24efb50)
#29 0x0000564724c670c1 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe0c1)
#30 0x0000564724c67373 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe373)
#31 0x0000564724c67746 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe746)
#32 0x0000564723778d9b main /home/nhat/github/triton_shared/tools/triton-shared-opt/triton-shared-opt.cpp:16:33
#33 0x00007fbcba9d3083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3
#34 0x000056472343b92e _start (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x29292e)
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir (51 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir:1 offset :37:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %res, %6 : tensor<256x16x!tt.ptr<bf16>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir:1 offset :37:5: note: see current operation: tt.store %arg1, %19 : tensor<256x16x!tt.ptr<bf16>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir:1 offset :37:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %res, %6 : tensor<256x16x!tt.ptr<bf16>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir:1 offset :37:5: note: see current operation: tt.store %arg1, %19 : tensor<256x16x!tt.ptr<bf16>>
module {
  tt.func @kernel(%arg0: !tt.ptr<bf16>, %arg1: tensor<256x16x!tt.ptr<bf16>>) {
    %c256 = arith.constant 256 : index
    %0 = tts.make_tptr %arg0 to sizes: [32, 256, 16], strides: [%c256, 1, 1], offsets: [0, 0, 0], shape: [0, 0, 0], order: [] : <bf16> to tensor<32x256x16x!tt.ptr<bf16>>
    %1 = "tts.load"(%0) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<32x256x16x!tt.ptr<bf16>>) -> tensor<32x256x16xbf16>
    %2 = "tt.reduce"(%1) <{axis = 0 : i32}> ({
    ^bb0(%arg2: bf16, %arg3: bf16):
      %3 = arith.cmpf ogt, %arg2, %arg3 : bf16
      %4 = arith.select %3, %arg2, %arg3 : bf16
      tt.reduce.return %4 : bf16
    }) : (tensor<32x256x16xbf16>) -> tensor<256x16xbf16>
    tt.store %arg1, %2 : tensor<256x16x!tt.ptr<bf16>>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xbf16> to !tt.ptr<bf16>
<block argument> of type 'memref<*xbf16>' at index: 0
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir
 #0 0x000055e3a63308c7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255c8c7)
 #1 0x000055e3a632e3ee llvm::sys::RunSignalHandlers() (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255a3ee)
 #2 0x000055e3a6330f7f SignalHandler(int) Signals.cpp:0:0
 #3 0x00007f4b16dde420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)
 #4 0x000055e3a43795d4 mlir::Operation::getResults() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:411:12
 #5 0x000055e3a43795d4 mlir::Operation::getResultTypes() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:423:47
 #6 0x000055e3a43795d4 (anonymous namespace)::StoreOpConverter::matchAndRewrite(mlir::triton::StoreOp, mlir::triton::StoreOpAdaptor, mlir::ConversionPatternRewriter&) const /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:306:24
 #7 0x000055e3a429481f mlir::OpConversionPattern<mlir::triton::StoreOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/Transforms/DialectConversion.h:545:3
 #8 0x000055e3a5f407c0 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c7c0)
 #9 0x000055e3a5f855eb mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_2::operator()() const PatternApplicator.cpp:0:0
#10 0x000055e3a5f8216f mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21ae16f)
#11 0x000055e3a5f41751 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0
#12 0x000055e3a5f40864 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c864)
#13 0x000055e3a5f41c6f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216dc6f)
#14 0x000055e3a5f483ab mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21743ab)
#15 0x000055e3a4377d9d (anonymous namespace)::TritonLoadStoreToMemrefPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:410:16
#16 0x000055e3a589b336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#17 0x000055e3a589bae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#18 0x000055e3a58a002f llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (mlir::OpPassManager&, mlir::Operation*)>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_6>(long, mlir::OpPassManager&, mlir::Operation*) Pass.cpp:0:0
#19 0x000055e3a4355ac5 llvm::LogicalResult::failed() const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:43:43
#20 0x000055e3a4355ac5 llvm::failed(llvm::LogicalResult) /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:71:58
#21 0x000055e3a4355ac5 (anonymous namespace)::TritonToLinalgExperimentalPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonToLinalgExperimental/TritonToLinalgExperimentalPass.cpp:63:9
#22 0x000055e3a589b336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#23 0x000055e3a589bae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#24 0x000055e3a589df95 mlir::PassManager::run(mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac9f95)
#25 0x000055e3a589766f performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0
#26 0x000055e3a589729d llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_2>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0
#27 0x000055e3a62c3f74 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef)::$_0::operator()(llvm::StringRef) const ToolUtilities.cpp:0:0
#28 0x000055e3a62c3b50 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x24efb50)
#29 0x000055e3a58920c1 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe0c1)
#30 0x000055e3a5892373 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe373)
#31 0x000055e3a5892746 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe746)
#32 0x000055e3a43a3d9b main /home/nhat/github/triton_shared/tools/triton-shared-opt/triton-shared-opt.cpp:16:33
#33 0x00007f4b16882083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3
#34 0x000055e3a406692e _start (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x29292e)
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_minmax_reduce.mlir (52 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_minmax_reduce.mlir' FAILED ********************
Exit Code: 1

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental  /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:1 offset :11:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %arg0, %63 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:1 offset :11:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:1 offset :11:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %arg0, %63 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:1 offset :11:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<i32>
module {
  tt.func public @minmax_sgt(%arg0: !tt.ptr<i32>) {
    %cst = arith.constant dense<0> : tensor<4096xi32>
    %0 = "tt.reduce"(%cst) <{axis = 0 : i32}> ({
    ^bb0(%arg1: i32, %arg2: i32):
      %1 = arith.cmpi sgt, %arg1, %arg2 : i32
      %2 = arith.select %1, %arg1, %arg2 : i32
      tt.reduce.return %2 : i32
    }) : (tensor<4096xi32>) -> i32
    tt.store %arg0, %0 : !tt.ptr<i32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xi32> to !tt.ptr<i32>
<block argument> of type 'memref<*xi32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:1 offset :3:30: error: failed to legalize unresolved materialization from ('memref<*xi32>') to '!tt.ptr<i32>' that remained live after conversion
  tt.func public @minmax_sgt(%arg0: !tt.ptr<i32>) {
                             ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:1 offset :3:30: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xi32>) -> !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:1 offset :3:3: note: see existing live user here: %3 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<i32>, i64) -> !tt.ptr<i32>
  tt.func public @minmax_sgt(%arg0: !tt.ptr<i32>) {
  ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:37 offset :12:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %arg0, %63 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:37 offset :12:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:37 offset :12:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %arg0, %63 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:37 offset :12:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<i32>
module {
  tt.func public @minmax_ugt(%arg0: !tt.ptr<i32>) {
    %cst = arith.constant dense<0> : tensor<4096xi32>
    %0 = "tt.reduce"(%cst) <{axis = 0 : i32}> ({
    ^bb0(%arg1: i32, %arg2: i32):
      %1 = arith.cmpi ugt, %arg1, %arg2 : i32
      %2 = arith.select %1, %arg1, %arg2 : i32
      tt.reduce.return %2 : i32
    }) : (tensor<4096xi32>) -> i32
    tt.store %arg0, %0 : !tt.ptr<i32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xi32> to !tt.ptr<i32>
<block argument> of type 'memref<*xi32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:37 offset :4:30: error: failed to legalize unresolved materialization from ('memref<*xi32>') to '!tt.ptr<i32>' that remained live after conversion
  tt.func public @minmax_ugt(%arg0: !tt.ptr<i32>) {
                             ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:37 offset :4:30: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xi32>) -> !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:37 offset :4:3: note: see existing live user here: %3 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<i32>, i64) -> !tt.ptr<i32>
  tt.func public @minmax_ugt(%arg0: !tt.ptr<i32>) {
  ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:74 offset :12:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %arg0, %63 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:74 offset :12:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:74 offset :12:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %arg0, %63 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:74 offset :12:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<i32>
module {
  tt.func public @minmax_slt(%arg0: !tt.ptr<i32>) {
    %cst = arith.constant dense<0> : tensor<4096xi32>
    %0 = "tt.reduce"(%cst) <{axis = 0 : i32}> ({
    ^bb0(%arg1: i32, %arg2: i32):
      %1 = arith.cmpi slt, %arg1, %arg2 : i32
      %2 = arith.select %1, %arg1, %arg2 : i32
      tt.reduce.return %2 : i32
    }) : (tensor<4096xi32>) -> i32
    tt.store %arg0, %0 : !tt.ptr<i32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xi32> to !tt.ptr<i32>
<block argument> of type 'memref<*xi32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:74 offset :4:30: error: failed to legalize unresolved materialization from ('memref<*xi32>') to '!tt.ptr<i32>' that remained live after conversion
  tt.func public @minmax_slt(%arg0: !tt.ptr<i32>) {
                             ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:74 offset :4:30: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xi32>) -> !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:74 offset :4:3: note: see existing live user here: %3 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<i32>, i64) -> !tt.ptr<i32>
  tt.func public @minmax_slt(%arg0: !tt.ptr<i32>) {
  ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:112 offset :12:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %arg0, %63 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:112 offset :12:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:112 offset :12:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %arg0, %63 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:112 offset :12:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<i32>
module {
  tt.func public @minmax_ult(%arg0: !tt.ptr<i32>) {
    %cst = arith.constant dense<0> : tensor<4096xi32>
    %0 = "tt.reduce"(%cst) <{axis = 0 : i32}> ({
    ^bb0(%arg1: i32, %arg2: i32):
      %1 = arith.cmpi ult, %arg1, %arg2 : i32
      %2 = arith.select %1, %arg1, %arg2 : i32
      tt.reduce.return %2 : i32
    }) : (tensor<4096xi32>) -> i32
    tt.store %arg0, %0 : !tt.ptr<i32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xi32> to !tt.ptr<i32>
<block argument> of type 'memref<*xi32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:112 offset :4:30: error: failed to legalize unresolved materialization from ('memref<*xi32>') to '!tt.ptr<i32>' that remained live after conversion
  tt.func public @minmax_ult(%arg0: !tt.ptr<i32>) {
                             ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:112 offset :4:30: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xi32>) -> !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:112 offset :4:3: note: see existing live user here: %3 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<i32>, i64) -> !tt.ptr<i32>
  tt.func public @minmax_ult(%arg0: !tt.ptr<i32>) {
  ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir:16:17: error: CHECK-LABEL: expected string not found in input
// CHECK-LABEL: func.func @minmax_sgt
                ^
<stdin>:1:1: note: scanning from here
// -----
^

Input file: <stdin>
Check file: /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_reduce.mlir

-dump-input=help explains the following input dump.

Input was:
<<<<<<
          1: // ----- 
label:16     X~~~~~~~~ error: no match found
          2: // ----- 
label:16     ~~~~~~~~~
          3: // ----- 
label:16     ~~~~~~~~~
>>>>>>

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_minmax.mlir (53 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_minmax.mlir' FAILED ********************
Exit Code: 1

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental  /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:1 offset :6:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %arg0, %1 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:1 offset :6:5: note: see current operation: tt.store %arg0, %1 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:1 offset :6:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %arg0, %1 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:1 offset :6:5: note: see current operation: tt.store %arg0, %1 : !tt.ptr<f32>
module {
  tt.func public @minmax_olt(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
    %0 = arith.cmpf olt, %arg1, %arg2 : f32
    %1 = arith.select %0, %arg1, %arg2 : f32
    tt.store %arg0, %1 : !tt.ptr<f32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:1 offset :3:30: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func public @minmax_olt(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
                             ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:1 offset :3:30: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xf32>) -> !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:1 offset :3:3: note: see existing live user here: %1 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
  tt.func public @minmax_olt(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
  ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:11 offset :7:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %arg0, %1 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:11 offset :7:5: note: see current operation: tt.store %arg0, %1 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:11 offset :7:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %arg0, %1 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:11 offset :7:5: note: see current operation: tt.store %arg0, %1 : !tt.ptr<f32>
module {
  tt.func public @minmax_ole(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
    %0 = arith.cmpf ole, %arg1, %arg2 : f32
    %1 = arith.select %0, %arg1, %arg2 : f32
    tt.store %arg0, %1 : !tt.ptr<f32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:11 offset :4:30: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func public @minmax_ole(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
                             ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:11 offset :4:30: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xf32>) -> !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:11 offset :4:3: note: see existing live user here: %1 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
  tt.func public @minmax_ole(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
  ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:22 offset :7:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %arg0, %1 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:22 offset :7:5: note: see current operation: tt.store %arg0, %1 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:22 offset :7:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %arg0, %1 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:22 offset :7:5: note: see current operation: tt.store %arg0, %1 : !tt.ptr<f32>
module {
  tt.func public @minmax_ogt(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
    %0 = arith.cmpf ogt, %arg1, %arg2 : f32
    %1 = arith.select %0, %arg1, %arg2 : f32
    tt.store %arg0, %1 : !tt.ptr<f32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:22 offset :4:30: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func public @minmax_ogt(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
                             ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:22 offset :4:30: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xf32>) -> !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:22 offset :4:3: note: see existing live user here: %1 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
  tt.func public @minmax_ogt(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
  ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:33 offset :7:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %arg0, %1 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:33 offset :7:5: note: see current operation: tt.store %arg0, %1 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:33 offset :7:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %arg0, %1 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:33 offset :7:5: note: see current operation: tt.store %arg0, %1 : !tt.ptr<f32>
module {
  tt.func public @minmax_oge(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
    %0 = arith.cmpf oge, %arg1, %arg2 : f32
    %1 = arith.select %0, %arg1, %arg2 : f32
    tt.store %arg0, %1 : !tt.ptr<f32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:33 offset :4:30: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func public @minmax_oge(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
                             ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:33 offset :4:30: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xf32>) -> !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:33 offset :4:3: note: see existing live user here: %1 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
  tt.func public @minmax_oge(%arg0: !tt.ptr<f32>, %arg1: f32, %arg2: f32) {
  ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir:44:17: error: CHECK-LABEL: expected string not found in input
// CHECK-LABEL: func.func @minmax_olt
                ^
<stdin>:1:1: note: scanning from here
// -----
^

Input file: <stdin>
Check file: /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax.mlir

-dump-input=help explains the following input dump.

Input was:
<<<<<<
          1: // ----- 
label:44     X~~~~~~~~ error: no match found
          2: // ----- 
label:44     ~~~~~~~~~
          3: // ----- 
label:44     ~~~~~~~~~
>>>>>>

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/ridiculously_nested_loops.mlir (54 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/ridiculously_nested_loops.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/ridiculously_nested_loops.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/ridiculously_nested_loops.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/ridiculously_nested_loops.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/ridiculously_nested_loops.mlir
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/ridiculously_nested_loops.mlir:32:13: error: failed to legalize unresolved materialization from ('tensor<2x2x!tt.ptr<f32>>') to 'tensor<2x2xi64>' that remained live after conversion
    %24:2 = scf.for %arg4 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg5 = %11, %arg6 = %15) -> (tensor<2x2x!tt.ptr<f32>>, tensor<2x2x!tt.ptr<f32>>)  : i32 {
            ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/ridiculously_nested_loops.mlir:32:13: note: see current operation: %7 = "builtin.unrealized_conversion_cast"(%6) : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xi64>
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/ridiculously_nested_loops.mlir:32:13: note: see existing live user here: 
%6:3 = scf.for %arg4 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg5 = %c0, %arg6 = %3, %arg7 = %c0) -> (index, tensor<2x2xi64>, index)  : i32 {
  %7 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg5, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
  %8 = "tts.load"(%7) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
  %9:4 = scf.for %arg8 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg9 = %arg5, %arg10 = %arg6, %arg11 = %arg7, %arg12 = %8) -> (index, tensor<2x2xi64>, index, tensor<2x2xf32>)  : i32 {
    %12 = arith.addi %arg9, %5 : index
    %13 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%12, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
    %14 = "tts.load"(%13) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
    %15:5 = scf.for %arg13 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg14 = %12, %arg15 = %arg10, %arg16 = %arg11, %arg17 = %arg12, %arg18 = %14) -> (index, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>)  : i32 {
      %17 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg16, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      %18 = arith.addi %arg14, %5 : index
      %19 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%18, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      %20 = builtin.unrealized_conversion_cast %19 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
      %21 = "tts.load"(%19) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
      "tts.store"(%17, %arg17) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
      %22 = arith.addi %arg16, %5 : index
      %23 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%22, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      "tts.store"(%23, %arg18) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
      %24 = arith.addi %22, %5 : index
      %25 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%24, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      "tts.store"(%25, %21) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
      %26 = arith.addi %24, %5 : index
      %27 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%26, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      %28 = builtin.unrealized_conversion_cast %27 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
      %29:7 = scf.for %arg19 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg20 = %arg17, %arg21 = %20, %arg22 = %18, %arg23 = %arg18, %arg24 = %21, %arg25 = %28, %arg26 = %26) -> (tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
        %31 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg22, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %32 = "tts.load"(%31) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
        %33:7 = scf.for %arg27 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26, %arg34 = %32) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>)  : i32 {
          %34 = arith.addi %arg29, %5 : index
          %35 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%34, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          %36 = builtin.unrealized_conversion_cast %35 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
          %37 = "tts.load"(%35) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
          %38:7 = scf.for %arg35 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg36 = %36, %arg37 = %34, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33, %arg41 = %arg34, %arg42 = %37) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>)  : i32 {
            %39 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg40, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            %40 = arith.addi %arg37, %5 : index
            %41 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%40, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            %42 = builtin.unrealized_conversion_cast %41 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
            %43 = "tts.load"(%41) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
            "tts.store"(%39, %arg41) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
            %44 = arith.addi %arg40, %5 : index
            %45 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%44, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            "tts.store"(%45, %arg42) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
            %46 = arith.addi %44, %5 : index
            %47 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%46, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            "tts.store"(%47, %43) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
            %48 = arith.addi %46, %5 : index
            %49 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%48, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            %50 = builtin.unrealized_conversion_cast %49 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
            %51:7 = scf.for %arg43 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg44 = %arg41, %arg45 = %42, %arg46 = %40, %arg47 = %arg42, %arg48 = %43, %arg49 = %50, %arg50 = %48) -> (tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
              %52 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg46, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
              %53 = "tts.load"(%52) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
              %54:7 = scf.for %arg51 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg52 = %arg45, %arg53 = %arg46, %arg54 = %arg47, %arg55 = %arg48, %arg56 = %arg49, %arg57 = %arg50, %arg58 = %53) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>)  : i32 {
                %55 = arith.addi %arg53, %5 : index
                %56 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%55, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                %57 = builtin.unrealized_conversion_cast %56 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                %58 = "tts.load"(%56) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                %59:7 = scf.for %arg59 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg60 = %57, %arg61 = %55, %arg62 = %arg55, %arg63 = %arg56, %arg64 = %arg57, %arg65 = %arg58, %arg66 = %58) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>)  : i32 {
                  %60 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg64, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                  %61 = arith.addi %arg61, %5 : index
                  %62 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%61, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                  %63 = builtin.unrealized_conversion_cast %62 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                  %64 = "tts.load"(%62) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                  "tts.store"(%60, %arg65) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                  %65 = arith.addi %arg64, %5 : index
                  %66 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%65, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                  "tts.store"(%66, %arg66) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                  %67 = arith.addi %65, %5 : index
                  %68 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%67, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                  "tts.store"(%68, %64) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                  %69 = arith.addi %67, %5 : index
                  %70 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%69, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                  %71 = builtin.unrealized_conversion_cast %70 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                  %72:7 = scf.for %arg67 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg68 = %arg65, %arg69 = %63, %arg70 = %61, %arg71 = %arg66, %arg72 = %64, %arg73 = %71, %arg74 = %69) -> (tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
                    %73 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg70, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                    %74 = "tts.load"(%73) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                    %75:6 = scf.for %arg75 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg76 = %arg69, %arg77 = %arg70, %arg78 = %arg71, %arg79 = %arg72, %arg80 = %arg73, %arg81 = %arg74) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
                      %76 = arith.addi %arg77, %5 : index
                      %77 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%76, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                      %78 = builtin.unrealized_conversion_cast %77 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                      %79 = "tts.load"(%77) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                      %80:5 = scf.for %arg82 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg83 = %78, %arg84 = %76, %arg85 = %arg79, %arg86 = %arg80, %arg87 = %arg81) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
                        %81 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg87, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                        %82 = arith.addi %arg84, %5 : index
                        %83 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%82, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                        %84 = builtin.unrealized_conversion_cast %83 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                        %85 = "tts.load"(%83) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                        "tts.store"(%81, %74) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                        %86 = arith.addi %arg87, %5 : index
                        %87 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%86, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                        "tts.store"(%87, %79) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                        %88 = arith.addi %86, %5 : index
                        %89 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%88, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                        "tts.store"(%89, %85) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                        %90 = arith.addi %88, %5 : index
                        %91 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%90, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                        %92 = builtin.unrealized_conversion_cast %91 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                        scf.yield %84, %82, %85, %92, %90 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index
                      }
                      scf.yield %80#0, %80#1, %79, %80#2, %80#3, %80#4 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
                    }
                    scf.yield %74, %75#0, %75#1, %75#2, %75#3, %75#4, %75#5 : tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
                  }
                  scf.yield %72#1, %72#2, %72#4, %72#5, %72#6, %72#0, %72#3 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>
                }
                scf.yield %59#0, %59#1, %59#6, %59#2, %59#3, %59#4, %59#5 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>
              }
              scf.yield %54#6, %54#0, %54#1, %54#2, %54#3, %54#4, %54#5 : tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
            }
            scf.yield %51#1, %51#2, %51#4, %51#5, %51#6, %51#0, %51#3 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>
          }
          scf.yield %38#0, %38#1, %38#6, %38#2, %38#3, %38#4, %38#5 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>
        }
        scf.yield %33#6, %33#0, %33#1, %33#2, %33#3, %33#4, %33#5 : tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
      }
      %30:7 = scf.for %arg19 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg20 = %29#0, %arg21 = %29#1, %arg22 = %29#2, %arg23 = %29#3, %arg24 = %29#4, %arg25 = %29#5, %arg26 = %29#6) -> (tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
        %31 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg22, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %32 = "tts.load"(%31) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
        %33:6 = scf.for %arg27 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
          %34 = arith.addi %arg29, %5 : index
          %35 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%34, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          %36 = builtin.unrealized_conversion_cast %35 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
          %37 = "tts.load"(%35) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
          %38:5 = scf.for %arg34 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg35 = %36, %arg36 = %34, %arg37 = %arg31, %arg38 = %arg32, %arg39 = %arg33) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
            %39 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg39, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            %40 = arith.addi %arg36, %5 : index
            %41 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%40, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            %42 = builtin.unrealized_conversion_cast %41 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
            %43 = "tts.load"(%41) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
            "tts.store"(%39, %32) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
            %44 = arith.addi %arg39, %5 : index
            %45 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%44, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            "tts.store"(%45, %37) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
            %46 = arith.addi %44, %5 : index
            %47 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%46, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            "tts.store"(%47, %43) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
            %48 = arith.addi %46, %5 : index
            %49 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%48, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            %50 = builtin.unrealized_conversion_cast %49 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
            scf.yield %42, %40, %43, %50, %48 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index
          }
          scf.yield %38#0, %38#1, %37, %38#2, %38#3, %38#4 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
        }
        scf.yield %32, %33#0, %33#1, %33#2, %33#3, %33#4, %33#5 : tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
      }
      scf.yield %30#2, %30#5, %30#6, %30#0, %30#3 : index, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>
    }
    %16 = arith.addi %15#0, %5 : index
    scf.yield %16, %15#1, %15#2, %15#3 : index, tensor<2x2xi64>, index, tensor<2x2xf32>
  }
  %10:3 = scf.for %arg8 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg9 = %9#0, %arg10 = %9#1, %arg11 = %9#2) -> (index, tensor<2x2xi64>, index)  : i32 {
    %12 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg9, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
    %13 = "tts.load"(%12) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
    %14:3 = scf.for %arg12 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg13 = %arg9, %arg14 = %arg10, %arg15 = %arg11) -> (index, tensor<2x2xi64>, index)  : i32 {
      %16 = arith.addi %arg13, %5 : index
      %17 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%16, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      %18 = "tts.load"(%17) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
      %19:3 = scf.for %arg16 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg17 = %16, %arg18 = %arg14, %arg19 = %arg15) -> (index, tensor<2x2xi64>, index)  : i32 {
        %20 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg19, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %21 = arith.addi %arg17, %5 : index
        %22 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%21, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %23 = "tts.load"(%22) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
        "tts.store"(%20, %13) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
        %24 = arith.addi %arg19, %5 : index
        %25 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%24, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        "tts.store"(%25, %18) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
        %26 = arith.addi %24, %5 : index
        %27 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%26, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        "tts.store"(%27, %23) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
        %28 = arith.addi %26, %5 : index
        %29 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%28, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %30 = builtin.unrealized_conversion_cast %29 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
        scf.yield %21, %30, %28 : index, tensor<2x2xi64>, index
      }
      scf.yield %19#0, %19#1, %19#2 : index, tensor<2x2xi64>, index
    }
    %15 = arith.addi %14#0, %5 : index
    scf.yield %15, %14#1, %14#2 : index, tensor<2x2xi64>, index
  }
  %11 = arith.addi %10#0, %5 : index
  scf.yield %11, %10#1, %10#2 : index, tensor<2x2xi64>, index
}
module {
  tt.func public @nested_who_knows_how_many_levels(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: i32, %arg3: i32) attributes {noinline = false} {
    %c0 = arith.constant 0 : index
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c2_i32 = arith.constant 2 : i32
    %0 = arith.index_cast %arg2 : i32 to index
    %1 = arith.index_cast %arg3 : i32 to index
    %2 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [0, 0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
    %3 = builtin.unrealized_conversion_cast %2 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
    %4 = arith.muli %arg3, %c2_i32 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6:3 = scf.for %arg4 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg5 = %c0, %arg6 = %3, %arg7 = %c0) -> (index, tensor<2x2xi64>, index)  : i32 {
      %7 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg5, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      %8 = "tts.load"(%7) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
      %9:4 = scf.for %arg8 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg9 = %arg5, %arg10 = %arg6, %arg11 = %arg7, %arg12 = %8) -> (index, tensor<2x2xi64>, index, tensor<2x2xf32>)  : i32 {
        %12 = arith.addi %arg9, %5 : index
        %13 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%12, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %14 = "tts.load"(%13) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
        %15:5 = scf.for %arg13 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg14 = %12, %arg15 = %arg10, %arg16 = %arg11, %arg17 = %arg12, %arg18 = %14) -> (index, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>)  : i32 {
          %17 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg16, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          %18 = arith.addi %arg14, %5 : index
          %19 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%18, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          %20 = builtin.unrealized_conversion_cast %19 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
          %21 = "tts.load"(%19) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
          "tts.store"(%17, %arg17) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
          %22 = arith.addi %arg16, %5 : index
          %23 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%22, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          "tts.store"(%23, %arg18) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
          %24 = arith.addi %22, %5 : index
          %25 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%24, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          "tts.store"(%25, %21) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
          %26 = arith.addi %24, %5 : index
          %27 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%26, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          %28 = builtin.unrealized_conversion_cast %27 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
          %29:7 = scf.for %arg19 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg20 = %arg17, %arg21 = %20, %arg22 = %18, %arg23 = %arg18, %arg24 = %21, %arg25 = %28, %arg26 = %26) -> (tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
            %31 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg22, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            %32 = "tts.load"(%31) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
            %33:7 = scf.for %arg27 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26, %arg34 = %32) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>)  : i32 {
              %34 = arith.addi %arg29, %5 : index
              %35 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%34, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
              %36 = builtin.unrealized_conversion_cast %35 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
              %37 = "tts.load"(%35) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
              %38:7 = scf.for %arg35 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg36 = %36, %arg37 = %34, %arg38 = %arg31, %arg39 = %arg32, %arg40 = %arg33, %arg41 = %arg34, %arg42 = %37) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>)  : i32 {
                %39 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg40, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                %40 = arith.addi %arg37, %5 : index
                %41 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%40, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                %42 = builtin.unrealized_conversion_cast %41 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                %43 = "tts.load"(%41) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                "tts.store"(%39, %arg41) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                %44 = arith.addi %arg40, %5 : index
                %45 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%44, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                "tts.store"(%45, %arg42) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                %46 = arith.addi %44, %5 : index
                %47 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%46, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                "tts.store"(%47, %43) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                %48 = arith.addi %46, %5 : index
                %49 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%48, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                %50 = builtin.unrealized_conversion_cast %49 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                %51:7 = scf.for %arg43 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg44 = %arg41, %arg45 = %42, %arg46 = %40, %arg47 = %arg42, %arg48 = %43, %arg49 = %50, %arg50 = %48) -> (tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
                  %52 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg46, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                  %53 = "tts.load"(%52) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                  %54:7 = scf.for %arg51 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg52 = %arg45, %arg53 = %arg46, %arg54 = %arg47, %arg55 = %arg48, %arg56 = %arg49, %arg57 = %arg50, %arg58 = %53) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>)  : i32 {
                    %55 = arith.addi %arg53, %5 : index
                    %56 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%55, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                    %57 = builtin.unrealized_conversion_cast %56 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                    %58 = "tts.load"(%56) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                    %59:7 = scf.for %arg59 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg60 = %57, %arg61 = %55, %arg62 = %arg55, %arg63 = %arg56, %arg64 = %arg57, %arg65 = %arg58, %arg66 = %58) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>)  : i32 {
                      %60 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg64, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                      %61 = arith.addi %arg61, %5 : index
                      %62 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%61, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                      %63 = builtin.unrealized_conversion_cast %62 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                      %64 = "tts.load"(%62) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                      "tts.store"(%60, %arg65) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                      %65 = arith.addi %arg64, %5 : index
                      %66 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%65, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                      "tts.store"(%66, %arg66) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                      %67 = arith.addi %65, %5 : index
                      %68 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%67, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                      "tts.store"(%68, %64) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                      %69 = arith.addi %67, %5 : index
                      %70 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%69, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                      %71 = builtin.unrealized_conversion_cast %70 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                      %72:7 = scf.for %arg67 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg68 = %arg65, %arg69 = %63, %arg70 = %61, %arg71 = %arg66, %arg72 = %64, %arg73 = %71, %arg74 = %69) -> (tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
                        %73 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg70, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                        %74 = "tts.load"(%73) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                        %75:6 = scf.for %arg75 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg76 = %arg69, %arg77 = %arg70, %arg78 = %arg71, %arg79 = %arg72, %arg80 = %arg73, %arg81 = %arg74) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
                          %76 = arith.addi %arg77, %5 : index
                          %77 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%76, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                          %78 = builtin.unrealized_conversion_cast %77 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                          %79 = "tts.load"(%77) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                          %80:5 = scf.for %arg82 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg83 = %78, %arg84 = %76, %arg85 = %arg79, %arg86 = %arg80, %arg87 = %arg81) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
                            %81 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg87, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                            %82 = arith.addi %arg84, %5 : index
                            %83 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%82, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                            %84 = builtin.unrealized_conversion_cast %83 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                            %85 = "tts.load"(%83) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                            "tts.store"(%81, %74) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                            %86 = arith.addi %arg87, %5 : index
                            %87 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%86, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                            "tts.store"(%87, %79) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                            %88 = arith.addi %86, %5 : index
                            %89 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%88, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                            "tts.store"(%89, %85) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                            %90 = arith.addi %88, %5 : index
                            %91 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%90, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                            %92 = builtin.unrealized_conversion_cast %91 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                            scf.yield %84, %82, %85, %92, %90 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index
                          }
                          scf.yield %80#0, %80#1, %79, %80#2, %80#3, %80#4 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
                        }
                        scf.yield %74, %75#0, %75#1, %75#2, %75#3, %75#4, %75#5 : tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
                      }
                      scf.yield %72#1, %72#2, %72#4, %72#5, %72#6, %72#0, %72#3 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>
                    }
                    scf.yield %59#0, %59#1, %59#6, %59#2, %59#3, %59#4, %59#5 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>
                  }
                  scf.yield %54#6, %54#0, %54#1, %54#2, %54#3, %54#4, %54#5 : tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
                }
                scf.yield %51#1, %51#2, %51#4, %51#5, %51#6, %51#0, %51#3 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>
              }
              scf.yield %38#0, %38#1, %38#6, %38#2, %38#3, %38#4, %38#5 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>
            }
            scf.yield %33#6, %33#0, %33#1, %33#2, %33#3, %33#4, %33#5 : tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
          }
          %30:7 = scf.for %arg19 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg20 = %29#0, %arg21 = %29#1, %arg22 = %29#2, %arg23 = %29#3, %arg24 = %29#4, %arg25 = %29#5, %arg26 = %29#6) -> (tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
            %31 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg22, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            %32 = "tts.load"(%31) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
            %33:6 = scf.for %arg27 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg28 = %arg21, %arg29 = %arg22, %arg30 = %arg23, %arg31 = %arg24, %arg32 = %arg25, %arg33 = %arg26) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
              %34 = arith.addi %arg29, %5 : index
              %35 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%34, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
              %36 = builtin.unrealized_conversion_cast %35 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
              %37 = "tts.load"(%35) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
              %38:5 = scf.for %arg34 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg35 = %36, %arg36 = %34, %arg37 = %arg31, %arg38 = %arg32, %arg39 = %arg33) -> (tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index)  : i32 {
                %39 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg39, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                %40 = arith.addi %arg36, %5 : index
                %41 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%40, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                %42 = builtin.unrealized_conversion_cast %41 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                %43 = "tts.load"(%41) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
                "tts.store"(%39, %32) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                %44 = arith.addi %arg39, %5 : index
                %45 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%44, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                "tts.store"(%45, %37) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                %46 = arith.addi %44, %5 : index
                %47 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%46, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                "tts.store"(%47, %43) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
                %48 = arith.addi %46, %5 : index
                %49 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%48, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
                %50 = builtin.unrealized_conversion_cast %49 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
                scf.yield %42, %40, %43, %50, %48 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xi64>, index
              }
              scf.yield %38#0, %38#1, %37, %38#2, %38#3, %38#4 : tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
            }
            scf.yield %32, %33#0, %33#1, %33#2, %33#3, %33#4, %33#5 : tensor<2x2xf32>, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>, tensor<2x2xi64>, index
          }
          scf.yield %30#2, %30#5, %30#6, %30#0, %30#3 : index, tensor<2x2xi64>, index, tensor<2x2xf32>, tensor<2x2xf32>
        }
        %16 = arith.addi %15#0, %5 : index
        scf.yield %16, %15#1, %15#2, %15#3 : index, tensor<2x2xi64>, index, tensor<2x2xf32>
      }
      %10:3 = scf.for %arg8 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg9 = %9#0, %arg10 = %9#1, %arg11 = %9#2) -> (index, tensor<2x2xi64>, index)  : i32 {
        %12 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg9, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %13 = "tts.load"(%12) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
        %14:3 = scf.for %arg12 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg13 = %arg9, %arg14 = %arg10, %arg15 = %arg11) -> (index, tensor<2x2xi64>, index)  : i32 {
          %16 = arith.addi %arg13, %5 : index
          %17 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%16, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          %18 = "tts.load"(%17) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
          %19:3 = scf.for %arg16 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg17 = %16, %arg18 = %arg14, %arg19 = %arg15) -> (index, tensor<2x2xi64>, index)  : i32 {
            %20 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg19, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            %21 = arith.addi %arg17, %5 : index
            %22 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%21, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            %23 = "tts.load"(%22) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
            "tts.store"(%20, %13) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
            %24 = arith.addi %arg19, %5 : index
            %25 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%24, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            "tts.store"(%25, %18) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
            %26 = arith.addi %24, %5 : index
            %27 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%26, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            "tts.store"(%27, %23) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
            %28 = arith.addi %26, %5 : index
            %29 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%28, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
            %30 = builtin.unrealized_conversion_cast %29 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
            scf.yield %21, %30, %28 : index, tensor<2x2xi64>, index
          }
          scf.yield %19#0, %19#1, %19#2 : index, tensor<2x2xi64>, index
        }
        %15 = arith.addi %14#0, %5 : index
        scf.yield %15, %14#1, %14#2 : index, tensor<2x2xi64>, index
      }
      %11 = arith.addi %10#0, %5 : index
      scf.yield %11, %10#1, %10#2 : index, tensor<2x2xi64>, index
    }
    tt.return
  }
}
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/ridiculously_nested_loops.mlir

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir (55 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir:1 offset :24:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %d, %10 : tensor<1024x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir:1 offset :24:5: note: see current operation: tt.store %arg3, %13 : tensor<1024x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir:1 offset :24:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %d, %10 : tensor<1024x!tt.ptr<f32>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir:1 offset :24:5: note: see current operation: tt.store %arg3, %13 : tensor<1024x!tt.ptr<f32>>
module {
  tt.func @kernel(%arg0: !tt.ptr<i1>, %arg1: !tt.ptr<f32>, %arg2: !tt.ptr<f32>, %arg3: tensor<1024x!tt.ptr<f32>>) {
    %0 = tts.make_tptr %arg0 to sizes: [1024], strides: [1], offsets: [0], shape: [0], order: [] : <i1> to tensor<1024x!tt.ptr<i1>>
    %1 = tts.make_tptr %arg1 to sizes: [1024], strides: [1], offsets: [0], shape: [0], order: [] : <f32> to tensor<1024x!tt.ptr<f32>>
    %2 = tts.make_tptr %arg2 to sizes: [1024], strides: [1], offsets: [0], shape: [0], order: [] : <f32> to tensor<1024x!tt.ptr<f32>>
    %3 = "tts.load"(%0) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<1024x!tt.ptr<i1>>) -> tensor<1024xi1>
    %4 = "tts.load"(%1) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<1024x!tt.ptr<f32>>) -> tensor<1024xf32>
    %5 = "tts.load"(%2) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<1024x!tt.ptr<f32>>) -> tensor<1024xf32>
    %6 = arith.select %3, %4, %5 : tensor<1024xi1>, tensor<1024xf32>
    tt.store %arg3, %6 : tensor<1024x!tt.ptr<f32>>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg2 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 2
ok case
%1 = unrealized_conversion_cast %arg1 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 1
ok case
%2 = unrealized_conversion_cast %arg0 : memref<*xi1> to !tt.ptr<i1>
<block argument> of type 'memref<*xi1>' at index: 0
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir
 #0 0x000055d0289188c7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255c8c7)
 #1 0x000055d0289163ee llvm::sys::RunSignalHandlers() (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255a3ee)
 #2 0x000055d028918f7f SignalHandler(int) Signals.cpp:0:0
 #3 0x00007f6f220d9420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)
 #4 0x000055d0269615d4 mlir::Operation::getResults() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:411:12
 #5 0x000055d0269615d4 mlir::Operation::getResultTypes() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:423:47
 #6 0x000055d0269615d4 (anonymous namespace)::StoreOpConverter::matchAndRewrite(mlir::triton::StoreOp, mlir::triton::StoreOpAdaptor, mlir::ConversionPatternRewriter&) const /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:306:24
 #7 0x000055d02687c81f mlir::OpConversionPattern<mlir::triton::StoreOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/Transforms/DialectConversion.h:545:3
 #8 0x000055d0285287c0 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c7c0)
 #9 0x000055d02856d5eb mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_2::operator()() const PatternApplicator.cpp:0:0
#10 0x000055d02856a16f mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21ae16f)
#11 0x000055d028529751 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0
#12 0x000055d028528864 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c864)
#13 0x000055d028529c6f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216dc6f)
#14 0x000055d0285303ab mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21743ab)
#15 0x000055d02695fd9d (anonymous namespace)::TritonLoadStoreToMemrefPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:410:16
#16 0x000055d027e83336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#17 0x000055d027e83ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#18 0x000055d027e8802f llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (mlir::OpPassManager&, mlir::Operation*)>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_6>(long, mlir::OpPassManager&, mlir::Operation*) Pass.cpp:0:0
#19 0x000055d02693dac5 llvm::LogicalResult::failed() const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:43:43
#20 0x000055d02693dac5 llvm::failed(llvm::LogicalResult) /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:71:58
#21 0x000055d02693dac5 (anonymous namespace)::TritonToLinalgExperimentalPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonToLinalgExperimental/TritonToLinalgExperimentalPass.cpp:63:9
#22 0x000055d027e83336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#23 0x000055d027e83ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#24 0x000055d027e85f95 mlir::PassManager::run(mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac9f95)
#25 0x000055d027e7f66f performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0
#26 0x000055d027e7f29d llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_2>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0
#27 0x000055d0288abf74 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef)::$_0::operator()(llvm::StringRef) const ToolUtilities.cpp:0:0
#28 0x000055d0288abb50 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x24efb50)
#29 0x000055d027e7a0c1 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe0c1)
#30 0x000055d027e7a373 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe373)
#31 0x000055d027e7a746 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe746)
#32 0x000055d02698bd9b main /home/nhat/github/triton_shared/tools/triton-shared-opt/triton-shared-opt.cpp:16:33
#33 0x00007f6f21b7d083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3
#34 0x000055d02664e92e _start (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x29292e)
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir (56 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir:12:7: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
      tt.store %arg11, %2 : !tt.ptr<f32>
      ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir:12:7: note: see current operation: tt.store %arg11, %3 : !tt.ptr<f32>
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir:12:7: remark: PtrAnalysis: Failed to rewrite StoreOp
      tt.store %arg11, %2 : !tt.ptr<f32>
      ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir:12:7: note: see current operation: tt.store %arg11, %3 : !tt.ptr<f32>
%6 = unrealized_conversion_cast %arg11 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
module {
  tt.func @reduce_kernel_2d_0d1d2de3de(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32) {
    %c0_i64 = arith.constant 0 : i64
    %c1_i32 = arith.constant 1 : i32
    %c5_i32 = arith.constant 5 : i32
    %c0_i32 = arith.constant 0 : i32
    %0 = arith.index_cast %arg7 : i32 to index
    %1 = arith.extsi %arg7 : i32 to i64
    %2 = arith.addi %c0_i64, %1 : i64
    %3 = arith.sitofp %arg7 : i32 to f32
    %4:3 = scf.for %arg10 = %c0_i32 to %c5_i32 step %c1_i32 iter_args(%arg11 = %2, %arg12 = %0, %arg13 = %0) -> (i64, index, index)  : i32 {
      %5 = "tts.create_ptr"(%arg1, %arg11) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
      %6 = builtin.unrealized_conversion_cast %arg11 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
      tt.store %5, %3 : !tt.ptr<f32>
      %7 = arith.index_cast %arg10 : i32 to index
      %8 = arith.addi %arg12, %7 : index
      %9 = arith.extsi %arg10 : i32 to i64
      %10 = arith.addi %arg11, %9 : i64
      %11 = arith.addi %arg13, %7 : index
      scf.yield %10, %8, %11 : i64, index, index
    }
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 1
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir:4:90: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func @reduce_kernel_2d_0d1d2de3de(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32) {
                                                                                         ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir:4:90: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg1) : (memref<*xf32>) -> !tt.ptr<f32>
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir:11:71: note: see existing live user here: %5 = "tts.create_ptr"(%0, %arg17) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
    %3:2 = scf.for %arg10 = %c0_i32 to %c5_i32 step %c1_i32 iter_args(%arg11 = %1, %arg12 = %0) -> (!tt.ptr<f32>, index)  : i32 {
                                                                      ^
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_no_iterargs.mlir (57 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_no_iterargs.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --canonicalize --triton-arith-to-linalg --structured-to-memref /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_no_iterargs.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_no_iterargs.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_no_iterargs.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --canonicalize --triton-arith-to-linalg --structured-to-memref /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_no_iterargs.mlir
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 1
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_no_iterargs.mlir:4:90: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func @reduce_kernel_2d_0d1d2de3de(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg2: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}, %arg3: i32 {tt.divisibility = 16 : i32, tt.max_divisibility = 16 : i32}, %arg4: i32, %arg5: i32, %arg6: i32, %arg7: i32, %arg8: i32, %arg9: i32) {
                                                                                         ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_no_iterargs.mlir:4:90: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg1) : (memref<*xf32>) -> !tt.ptr<f32>
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_no_iterargs.mlir:8:10: note: see existing live user here: %1 = tt.addptr %0, %arg7 : !tt.ptr<f32>, i32
    %0 = tt.addptr %arg1, %arg7 : !tt.ptr<f32>, i32
         ^
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_no_iterargs.mlir

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir (58 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir' FAILED ********************
Exit Code: 1

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental  /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:1 offset :11:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %arg0, %63 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:1 offset :11:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:1 offset :11:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %arg0, %63 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:1 offset :11:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<f32>
module {
  tt.func public @maxnumf(%arg0: !tt.ptr<f32>) {
    %cst = arith.constant dense<0.000000e+00> : tensor<4096xf32>
    %0 = "tt.reduce"(%cst) <{axis = 0 : i32}> ({
    ^bb0(%arg1: f32, %arg2: f32):
      %1 = arith.maxnumf %arg1, %arg2 : f32
      tt.reduce.return %1 : f32
    }) : (tensor<4096xf32>) -> f32
    tt.store %arg0, %0 : !tt.ptr<f32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:1 offset :4:27: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func public @maxnumf(%arg0: !tt.ptr<f32>) {
                          ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:1 offset :4:27: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xf32>) -> !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:1 offset :4:3: note: see existing live user here: %3 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
  tt.func public @maxnumf(%arg0: !tt.ptr<f32>) {
  ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:37 offset :12:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %arg0, %63 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:37 offset :12:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:37 offset :12:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %arg0, %63 : !tt.ptr<f32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:37 offset :12:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<f32>
module {
  tt.func public @minnumf(%arg0: !tt.ptr<f32>) {
    %cst = arith.constant dense<0.000000e+00> : tensor<4096xf32>
    %0 = "tt.reduce"(%cst) <{axis = 0 : i32}> ({
    ^bb0(%arg1: f32, %arg2: f32):
      %1 = arith.minnumf %arg1, %arg2 : f32
      tt.reduce.return %1 : f32
    }) : (tensor<4096xf32>) -> f32
    tt.store %arg0, %0 : !tt.ptr<f32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:37 offset :5:27: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func public @minnumf(%arg0: !tt.ptr<f32>) {
                          ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:37 offset :5:27: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xf32>) -> !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:37 offset :5:3: note: see existing live user here: %3 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
  tt.func public @minnumf(%arg0: !tt.ptr<f32>) {
  ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir:16:17: error: CHECK-LABEL: expected string not found in input
// CHECK-LABEL: func.func @maxnumf
                ^
<stdin>:1:1: note: scanning from here
// -----
^

Input file: <stdin>
Check file: /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir

-dump-input=help explains the following input dump.

Input was:
<<<<<<
          1: // ----- 
label:16     X~~~~~~~~ error: no match found
>>>>>>

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir (59 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir:1 offset :25:9: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
        tt.store %c, %6 : tensor<1024x!tt.ptr<f32>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir:1 offset :25:9: note: see current operation: tt.store %arg2, %14 : tensor<1024x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir:1 offset :25:9: remark: PtrAnalysis: Failed to rewrite StoreOp
        tt.store %c, %6 : tensor<1024x!tt.ptr<f32>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir:1 offset :25:9: note: see current operation: tt.store %arg2, %14 : tensor<1024x!tt.ptr<f32>>
module {
  tt.func @kernel(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: tensor<1024x!tt.ptr<f32>>) {
    %0 = tts.make_tptr %arg0 to sizes: [1024], strides: [1], offsets: [0], shape: [0], order: [] : <f32> to tensor<1024x!tt.ptr<f32>>
    %1 = tts.make_tptr %arg1 to sizes: [1024], strides: [1], offsets: [0], shape: [0], order: [] : <f32> to tensor<1024x!tt.ptr<f32>>
    %2 = "tts.load"(%0) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<1024x!tt.ptr<f32>>) -> tensor<1024xf32>
    %3 = "tts.load"(%1) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<1024x!tt.ptr<f32>>) -> tensor<1024xf32>
    %4 = arith.addf %2, %3 : tensor<1024xf32>
    %5 = arith.subf %4, %3 : tensor<1024xf32>
    %6 = arith.mulf %5, %3 : tensor<1024xf32>
    %7 = arith.divf %6, %3 : tensor<1024xf32>
    %8 = arith.cmpf oeq, %7, %3 : tensor<1024xf32>
    %9 = arith.select %8, %2, %3 : tensor<1024xi1>, tensor<1024xf32>
    tt.store %arg2, %9 : tensor<1024x!tt.ptr<f32>>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 1
ok case
%1 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir
 #0 0x000055c20a3228c7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255c8c7)
 #1 0x000055c20a3203ee llvm::sys::RunSignalHandlers() (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255a3ee)
 #2 0x000055c20a322f7f SignalHandler(int) Signals.cpp:0:0
 #3 0x00007f7e9a66d420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)
 #4 0x000055c20836b5d4 mlir::Operation::getResults() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:411:12
 #5 0x000055c20836b5d4 mlir::Operation::getResultTypes() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:423:47
 #6 0x000055c20836b5d4 (anonymous namespace)::StoreOpConverter::matchAndRewrite(mlir::triton::StoreOp, mlir::triton::StoreOpAdaptor, mlir::ConversionPatternRewriter&) const /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:306:24
 #7 0x000055c20828681f mlir::OpConversionPattern<mlir::triton::StoreOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/Transforms/DialectConversion.h:545:3
 #8 0x000055c209f327c0 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c7c0)
 #9 0x000055c209f775eb mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_2::operator()() const PatternApplicator.cpp:0:0
#10 0x000055c209f7416f mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21ae16f)
#11 0x000055c209f33751 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0
#12 0x000055c209f32864 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c864)
#13 0x000055c209f33c6f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216dc6f)
#14 0x000055c209f3a3ab mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21743ab)
#15 0x000055c208369d9d (anonymous namespace)::TritonLoadStoreToMemrefPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:410:16
#16 0x000055c20988d336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#17 0x000055c20988dae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#18 0x000055c20989202f llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (mlir::OpPassManager&, mlir::Operation*)>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_6>(long, mlir::OpPassManager&, mlir::Operation*) Pass.cpp:0:0
#19 0x000055c208347ac5 llvm::LogicalResult::failed() const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:43:43
#20 0x000055c208347ac5 llvm::failed(llvm::LogicalResult) /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:71:58
#21 0x000055c208347ac5 (anonymous namespace)::TritonToLinalgExperimentalPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonToLinalgExperimental/TritonToLinalgExperimentalPass.cpp:63:9
#22 0x000055c20988d336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#23 0x000055c20988dae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#24 0x000055c20988ff95 mlir::PassManager::run(mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac9f95)
#25 0x000055c20988966f performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0
#26 0x000055c20988929d llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_2>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0
#27 0x000055c20a2b5f74 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef)::$_0::operator()(llvm::StringRef) const ToolUtilities.cpp:0:0
#28 0x000055c20a2b5b50 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x24efb50)
#29 0x000055c2098840c1 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe0c1)
#30 0x000055c209884373 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe373)
#31 0x000055c209884746 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe746)
#32 0x000055c208395d9b main /home/nhat/github/triton_shared/tools/triton-shared-opt/triton-shared-opt.cpp:16:33
#33 0x00007f7e9a111083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3
#34 0x000055c20805892e _start (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x29292e)
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_addi_reduce.mlir (60 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_addi_reduce.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental  /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir:1 offset :11:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %arg0, %63 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir:1 offset :11:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir:1 offset :11:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %arg0, %63 : !tt.ptr<i32>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir:1 offset :11:5: note: see current operation: tt.store %arg0, %0 : !tt.ptr<i32>
module {
  tt.func public @addi(%arg0: !tt.ptr<i32>) {
    %cst = arith.constant dense<0> : tensor<4096xi32>
    %0 = "tt.reduce"(%cst) <{axis = 0 : i32}> ({
    ^bb0(%arg1: i32, %arg2: i32):
      %1 = arith.addi %arg1, %arg2 : i32
      tt.reduce.return %1 : i32
    }) : (tensor<4096xi32>) -> i32
    tt.store %arg0, %0 : !tt.ptr<i32>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xi32> to !tt.ptr<i32>
<block argument> of type 'memref<*xi32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir:1 offset :4:24: error: failed to legalize unresolved materialization from ('memref<*xi32>') to '!tt.ptr<i32>' that remained live after conversion
  tt.func public @addi(%arg0: !tt.ptr<i32>) {
                       ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir:1 offset :4:24: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xi32>) -> !tt.ptr<i32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir:1 offset :4:3: note: see existing live user here: %3 = "tts.create_ptr"(%0, %c0_i64) : (!tt.ptr<i32>, i64) -> !tt.ptr<i32>
  tt.func public @addi(%arg0: !tt.ptr<i32>) {
  ^
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_addi_reduce.mlir

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir (61 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir:1 offset :30:9: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
        tt.store %d, %100 : tensor<128x128x!tt.ptr<f32>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir:1 offset :30:9: note: see current operation: tt.store %arg3, %19 : tensor<128x128x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir:1 offset :30:9: remark: PtrAnalysis: Failed to rewrite StoreOp
        tt.store %d, %100 : tensor<128x128x!tt.ptr<f32>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir:1 offset :30:9: note: see current operation: tt.store %arg3, %19 : tensor<128x128x!tt.ptr<f32>>
module {
  tt.func @kernel(%arg0: !tt.ptr<i1>, %arg1: !tt.ptr<f32>, %arg2: !tt.ptr<f32>, %arg3: tensor<128x128x!tt.ptr<f32>>) {
    %0 = tts.make_tptr %arg0 to sizes: [128, 128], strides: [1, 1], offsets: [0, 0], shape: [0, 0], order: [] : <i1> to tensor<128x128x!tt.ptr<i1>>
    %1 = tts.make_tptr %arg1 to sizes: [128, 128], strides: [1, 1], offsets: [0, 0], shape: [0, 0], order: [] : <f32> to tensor<128x128x!tt.ptr<f32>>
    %2 = tts.make_tptr %arg2 to sizes: [128, 128], strides: [1, 1], offsets: [0, 0], shape: [0, 0], order: [] : <f32> to tensor<128x128x!tt.ptr<f32>>
    %3 = "tts.load"(%0) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<128x128x!tt.ptr<i1>>) -> tensor<128x128xi1>
    %4 = "tts.load"(%1) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<128x128x!tt.ptr<f32>>) -> tensor<128x128xf32>
    %5 = "tts.load"(%2) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<128x128x!tt.ptr<f32>>) -> tensor<128x128xf32>
    %6 = arith.select %3, %4, %5 : tensor<128x128xi1>, tensor<128x128xf32>
    tt.store %arg3, %6 : tensor<128x128x!tt.ptr<f32>>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg2 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 2
ok case
%1 = unrealized_conversion_cast %arg1 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 1
ok case
%2 = unrealized_conversion_cast %arg0 : memref<*xi1> to !tt.ptr<i1>
<block argument> of type 'memref<*xi1>' at index: 0
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir
 #0 0x000055cf728ba8c7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255c8c7)
 #1 0x000055cf728b83ee llvm::sys::RunSignalHandlers() (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255a3ee)
 #2 0x000055cf728baf7f SignalHandler(int) Signals.cpp:0:0
 #3 0x00007f0ad309a420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)
 #4 0x000055cf709035d4 mlir::Operation::getResults() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:411:12
 #5 0x000055cf709035d4 mlir::Operation::getResultTypes() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:423:47
 #6 0x000055cf709035d4 (anonymous namespace)::StoreOpConverter::matchAndRewrite(mlir::triton::StoreOp, mlir::triton::StoreOpAdaptor, mlir::ConversionPatternRewriter&) const /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:306:24
 #7 0x000055cf7081e81f mlir::OpConversionPattern<mlir::triton::StoreOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/Transforms/DialectConversion.h:545:3
 #8 0x000055cf724ca7c0 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c7c0)
 #9 0x000055cf7250f5eb mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_2::operator()() const PatternApplicator.cpp:0:0
#10 0x000055cf7250c16f mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21ae16f)
#11 0x000055cf724cb751 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0
#12 0x000055cf724ca864 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c864)
#13 0x000055cf724cbc6f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216dc6f)
#14 0x000055cf724d23ab mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21743ab)
#15 0x000055cf70901d9d (anonymous namespace)::TritonLoadStoreToMemrefPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:410:16
#16 0x000055cf71e25336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#17 0x000055cf71e25ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#18 0x000055cf71e2a02f llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (mlir::OpPassManager&, mlir::Operation*)>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_6>(long, mlir::OpPassManager&, mlir::Operation*) Pass.cpp:0:0
#19 0x000055cf708dfac5 llvm::LogicalResult::failed() const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:43:43
#20 0x000055cf708dfac5 llvm::failed(llvm::LogicalResult) /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:71:58
#21 0x000055cf708dfac5 (anonymous namespace)::TritonToLinalgExperimentalPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonToLinalgExperimental/TritonToLinalgExperimentalPass.cpp:63:9
#22 0x000055cf71e25336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#23 0x000055cf71e25ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#24 0x000055cf71e27f95 mlir::PassManager::run(mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac9f95)
#25 0x000055cf71e2166f performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0
#26 0x000055cf71e2129d llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_2>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0
#27 0x000055cf7284df74 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef)::$_0::operator()(llvm::StringRef) const ToolUtilities.cpp:0:0
#28 0x000055cf7284db50 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x24efb50)
#29 0x000055cf71e1c0c1 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe0c1)
#30 0x000055cf71e1c373 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe373)
#31 0x000055cf71e1c746 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe746)
#32 0x000055cf7092dd9b main /home/nhat/github/triton_shared/tools/triton-shared-opt/triton-shared-opt.cpp:16:33
#33 0x00007f0ad2b3e083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3
#34 0x000055cf705f092e _start (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x29292e)
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir

--

********************
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/convert_extern_elementwise.mlir (62 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_chain.mlir (63 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/addptr_chain.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :16:12: remark: PtrAnalysis: scalar loadOp will not be rewritten
      %6 = tt.load %2 : !tt.ptr<f32>
           ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :16:12: note: see current operation: %16 = tt.load %8 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :16:12: remark: PtrAnalysis: Failed to rewrite LoadOp
      %6 = tt.load %2 : !tt.ptr<f32>
           ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :16:12: note: see current operation: %16 = tt.load %8 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :17:12: remark: PtrAnalysis: scalar loadOp will not be rewritten
      %7 = tt.load %3 : !tt.ptr<f32>
           ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :17:12: note: see current operation: %17 = tt.load %10 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :17:12: remark: PtrAnalysis: Failed to rewrite LoadOp
      %7 = tt.load %3 : !tt.ptr<f32>
           ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :17:12: note: see current operation: %17 = tt.load %10 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :18:7: remark: PtrAnalysis: scalar storeOp will not be rewritten
      tt.store %4, %6 : !tt.ptr<f32>
      ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :18:7: note: see current operation: tt.store %13, %16 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :18:7: remark: PtrAnalysis: Failed to rewrite StoreOp
      tt.store %4, %6 : !tt.ptr<f32>
      ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :18:7: note: see current operation: tt.store %13, %16 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :19:7: remark: PtrAnalysis: scalar storeOp will not be rewritten
      tt.store %5, %7 : !tt.ptr<f32>
      ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :19:7: note: see current operation: tt.store %15, %17 : !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :19:7: remark: PtrAnalysis: Failed to rewrite StoreOp
      tt.store %5, %7 : !tt.ptr<f32>
      ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :19:7: note: see current operation: tt.store %15, %17 : !tt.ptr<f32>
%14 = unrealized_conversion_cast %13 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
%8 = unrealized_conversion_cast %7 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
%19 = unrealized_conversion_cast %18 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
%12 = unrealized_conversion_cast %11 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
module {
  tt.func public @addptr(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>) attributes {noinline = false} {
    %c0_i64 = arith.constant 0 : i64
    %c0_i64_0 = arith.constant 0 : i64
    %c2_i32 = arith.constant 2 : i32
    %c10_i32 = arith.constant 10 : i32
    %c0_i32 = arith.constant 0 : i32
    %c1_i32 = arith.constant 1 : i32
    %0 = arith.extsi %c1_i32 : i32 to i64
    %1 = arith.addi %c0_i64_0, %0 : i64
    %2 = arith.extsi %c1_i32 : i32 to i64
    %3 = arith.addi %c0_i64, %2 : i64
    scf.for %arg2 = %c0_i32 to %c10_i32 step %c2_i32  : i32 {
      %4 = arith.extsi %arg2 : i32 to i64
      %5 = arith.addi %1, %4 : i64
      %6 = "tts.create_ptr"(%arg0, %5) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
      %7 = builtin.unrealized_conversion_cast %5 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
      %8 = arith.extsi %c1_i32 : i32 to i64
      %9 = arith.addi %5, %8 : i64
      %10 = "tts.create_ptr"(%arg0, %9) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
      %11 = builtin.unrealized_conversion_cast %9 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
      %12 = arith.extsi %arg2 : i32 to i64
      %13 = arith.addi %3, %12 : i64
      %14 = "tts.create_ptr"(%arg1, %13) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
      %15 = builtin.unrealized_conversion_cast %13 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
      %16 = arith.extsi %c1_i32 : i32 to i64
      %17 = arith.addi %13, %16 : i64
      %18 = "tts.create_ptr"(%arg1, %17) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
      %19 = builtin.unrealized_conversion_cast %17 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
      %20 = tt.load %6 : !tt.ptr<f32>
      %21 = tt.load %10 : !tt.ptr<f32>
      tt.store %14, %20 : !tt.ptr<f32>
      tt.store %18, %21 : !tt.ptr<f32>
    }
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 1
ok case
%1 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :4:47: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func public @addptr(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>) attributes {noinline = false} {
                                              ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :4:47: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg1) : (memref<*xf32>) -> !tt.ptr<f32>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir:1 offset :14:12: note: see existing live user here: %9 = "tts.create_ptr"(%0, %8) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
      %4 = tt.addptr %1, %arg2 : !tt.ptr<f32>, i32
           ^
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_chain.mlir

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_loopback.mlir (64 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_loopback.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir:1 offset :11:11: remark: PtrAnalysis: scalar loadOp will not be rewritten
    %10 = tt.load %0 {cache = 1 : i32, evict = 1 : i32, isVolatile = false}: !tt.ptr<bf16>
          ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir:1 offset :11:11: note: see current operation: %4 = tt.load %1 : !tt.ptr<bf16>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir:1 offset :11:11: remark: PtrAnalysis: Failed to rewrite LoadOp
    %10 = tt.load %0 {cache = 1 : i32, evict = 1 : i32, isVolatile = false}: !tt.ptr<bf16>
          ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir:1 offset :11:11: note: see current operation: %4 = tt.load %1 : !tt.ptr<bf16>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir:1 offset :12:5: remark: PtrAnalysis: scalar storeOp will not be rewritten
    tt.store %1, %10 : !tt.ptr<bf16>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir:1 offset :12:5: note: see current operation: tt.store %3, %4 : !tt.ptr<bf16>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir:1 offset :12:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %1, %10 : !tt.ptr<bf16>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir:1 offset :12:5: note: see current operation: tt.store %3, %4 : !tt.ptr<bf16>
%7 = unrealized_conversion_cast %6 : i64 to !tt.ptr<bf16> {"reconvert-offset-to-ptr"}
%4 = unrealized_conversion_cast %3 : i64 to !tt.ptr<bf16> {"reconvert-offset-to-ptr"}
module {
  tt.func @kernel(%arg0: !tt.ptr<bf16>, %arg1: !tt.ptr<bf16>, %arg2: i32) {
    %c0_i64 = arith.constant 0 : i64
    %c0_i64_0 = arith.constant 0 : i64
    %0 = arith.extsi %arg2 : i32 to i64
    %1 = arith.addi %c0_i64_0, %0 : i64
    %2 = "tts.create_ptr"(%arg0, %1) : (!tt.ptr<bf16>, i64) -> !tt.ptr<bf16>
    %3 = builtin.unrealized_conversion_cast %1 : i64 to !tt.ptr<bf16> {"reconvert-offset-to-ptr"}
    %4 = arith.extsi %arg2 : i32 to i64
    %5 = arith.addi %c0_i64, %4 : i64
    %6 = "tts.create_ptr"(%arg1, %5) : (!tt.ptr<bf16>, i64) -> !tt.ptr<bf16>
    %7 = builtin.unrealized_conversion_cast %5 : i64 to !tt.ptr<bf16> {"reconvert-offset-to-ptr"}
    %8 = tt.load %2 : !tt.ptr<bf16>
    tt.store %6, %8 : !tt.ptr<bf16>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xbf16> to !tt.ptr<bf16>
<block argument> of type 'memref<*xbf16>' at index: 1
ok case
%1 = unrealized_conversion_cast %arg0 : memref<*xbf16> to !tt.ptr<bf16>
<block argument> of type 'memref<*xbf16>' at index: 0
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir:1 offset :6:3: error: failed to legalize unresolved materialization from ('memref<*xbf16>') to '!tt.ptr<bf16>' that remained live after conversion
  %arg1 : !tt.ptr<bf16>,
  ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir:1 offset :6:3: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg1) : (memref<*xbf16>) -> !tt.ptr<bf16>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir:1 offset :10:10: note: see existing live user here: %5 = "tts.create_ptr"(%0, %4) : (!tt.ptr<bf16>, i64) -> !tt.ptr<bf16>
    %1 = tt.addptr %arg1, %arg2 : !tt.ptr<bf16>, i32
         ^
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/addptr_scalar_loopback.mlir

--

********************
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/wraparound_stacked.mlir (65 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/nested_loops.mlir (66 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/nested_loops.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/nested_loops.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/nested_loops.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/nested_loops.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/nested_loops.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/nested_loops.mlir:1 offset :109:13: error: failed to legalize unresolved materialization from ('tensor<2x2x!tt.ptr<f32>>') to 'tensor<2x2xi64>' that remained live after conversion
    %20:2 = scf.for %arg4 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg5 = %11, %arg6 = %15) -> (tensor<2x2x!tt.ptr<f32>>, tensor<2x2x!tt.ptr<f32>>)  : i32 {
            ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/nested_loops.mlir:1 offset :109:13: note: see current operation: %7 = "builtin.unrealized_conversion_cast"(%6) : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xi64>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/nested_loops.mlir:1 offset :109:13: note: see existing live user here: 
%6:3 = scf.for %arg4 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg5 = %c0, %arg6 = %3, %arg7 = %c0) -> (index, tensor<2x2xi64>, index)  : i32 {
  %7 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg5, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
  %8 = "tts.load"(%7) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
  %9:3 = scf.for %arg8 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg9 = %arg5, %arg10 = %arg6, %arg11 = %arg7) -> (index, tensor<2x2xi64>, index)  : i32 {
    %11 = arith.addi %arg9, %5 : index
    %12 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%11, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
    %13 = "tts.load"(%12) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
    %14:3 = scf.for %arg12 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg13 = %11, %arg14 = %arg10, %arg15 = %arg11) -> (index, tensor<2x2xi64>, index)  : i32 {
      %15 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg15, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      %16 = arith.addi %arg13, %5 : index
      %17 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%16, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      %18 = "tts.load"(%17) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
      "tts.store"(%15, %8) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
      %19 = arith.addi %arg15, %5 : index
      %20 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%19, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      "tts.store"(%20, %13) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
      %21 = arith.addi %19, %5 : index
      %22 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%21, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      "tts.store"(%22, %18) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
      %23 = arith.addi %21, %5 : index
      %24 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%23, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      %25 = builtin.unrealized_conversion_cast %24 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
      scf.yield %16, %25, %23 : index, tensor<2x2xi64>, index
    }
    scf.yield %14#0, %14#1, %14#2 : index, tensor<2x2xi64>, index
  }
  %10 = arith.addi %9#0, %5 : index
  scf.yield %10, %9#1, %9#2 : index, tensor<2x2xi64>, index
}
module {
  tt.func public @nested2_complex_body(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: i32, %arg3: i32) attributes {noinline = false} {
    %c3 = arith.constant 3 : index
    %c1 = arith.constant 1 : index
    %c0 = arith.constant 0 : index
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c2_i32 = arith.constant 2 : i32
    %0 = arith.index_cast %arg2 : i32 to index
    %1 = arith.index_cast %arg3 : i32 to index
    %2 = arith.muli %arg2, %c2_i32 : i32
    %3 = arith.index_cast %2 : i32 to index
    %4:2 = scf.for %arg4 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg5 = %c0, %arg6 = %c0) -> (index, index)  : i32 {
      %5 = arith.addi %arg5, %c1 : index
      %6 = arith.addi %arg6, %c1 : index
      %7:2 = scf.for %arg7 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg8 = %5, %arg9 = %6) -> (index, index)  : i32 {
        %12 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg9, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %13 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg8, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %14 = "tts.load"(%13) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
        "tts.store"(%12, %14) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
        %15 = arith.addi %arg8, %c3 : index
        %16 = arith.addi %arg9, %c3 : index
        scf.yield %15, %16 : index, index
      }
      %8 = arith.addi %arg5, %3 : index
      %9 = arith.addi %8, %c1 : index
      %10 = arith.addi %arg6, %3 : index
      %11 = arith.addi %10, %c1 : index
      scf.yield %9, %11 : index, index
    }
    tt.return
  }
  tt.func public @nested2_use_loop_results(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: i32, %arg3: i32) attributes {noinline = false} {
    %c0 = arith.constant 0 : index
    %c1_i32 = arith.constant 1 : i32
    %c2_i32 = arith.constant 2 : i32
    %c0_i32 = arith.constant 0 : i32
    %c4_i32 = arith.constant 4 : i32
    %0 = arith.index_cast %arg2 : i32 to index
    %1 = arith.index_cast %arg3 : i32 to index
    %2 = arith.muli %arg3, %c4_i32 : i32
    %3 = arith.index_cast %2 : i32 to index
    %4:2 = scf.for %arg4 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg5 = %c0, %arg6 = %c0) -> (index, index)  : i32 {
      %5 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg6, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      %6 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg5, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      %7 = "tts.load"(%6) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
      "tts.store"(%5, %7) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
      %8 = arith.addi %arg5, %3 : index
      %9 = arith.addi %arg6, %3 : index
      %10:2 = scf.for %arg7 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg8 = %8, %arg9 = %9) -> (index, index)  : i32 {
        %11 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg9, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %12 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg8, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %13 = "tts.load"(%12) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
        "tts.store"(%11, %13) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
        %14 = arith.addi %arg8, %3 : index
        %15 = arith.addi %arg9, %3 : index
        scf.yield %14, %15 : index, index
      }
      scf.yield %10#0, %10#1 : index, index
    }
    tt.return
  }
  tt.func public @nested3(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: i32, %arg3: i32) attributes {noinline = false} {
    %c0 = arith.constant 0 : index
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c2_i32 = arith.constant 2 : i32
    %0 = arith.index_cast %arg2 : i32 to index
    %1 = arith.index_cast %arg3 : i32 to index
    %2 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [0, 0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
    %3 = builtin.unrealized_conversion_cast %2 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
    %4 = arith.muli %arg3, %c2_i32 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6:3 = scf.for %arg4 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg5 = %c0, %arg6 = %3, %arg7 = %c0) -> (index, tensor<2x2xi64>, index)  : i32 {
      %7 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg5, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
      %8 = "tts.load"(%7) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
      %9:3 = scf.for %arg8 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg9 = %arg5, %arg10 = %arg6, %arg11 = %arg7) -> (index, tensor<2x2xi64>, index)  : i32 {
        %11 = arith.addi %arg9, %5 : index
        %12 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%11, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %13 = "tts.load"(%12) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
        %14:3 = scf.for %arg12 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg13 = %11, %arg14 = %arg10, %arg15 = %arg11) -> (index, tensor<2x2xi64>, index)  : i32 {
          %15 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg15, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          %16 = arith.addi %arg13, %5 : index
          %17 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%16, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          %18 = "tts.load"(%17) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
          "tts.store"(%15, %8) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
          %19 = arith.addi %arg15, %5 : index
          %20 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%19, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          "tts.store"(%20, %13) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
          %21 = arith.addi %19, %5 : index
          %22 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%21, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          "tts.store"(%22, %18) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
          %23 = arith.addi %21, %5 : index
          %24 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%23, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
          %25 = builtin.unrealized_conversion_cast %24 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
          scf.yield %16, %25, %23 : index, tensor<2x2xi64>, index
        }
        scf.yield %14#0, %14#1, %14#2 : index, tensor<2x2xi64>, index
      }
      %10 = arith.addi %9#0, %5 : index
      scf.yield %10, %9#1, %9#2 : index, tensor<2x2xi64>, index
    }
    tt.return
  }
  tt.func public @nested_use_same_level_loop_result(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: i32, %arg3: i32) attributes {noinline = false} {
    %c0 = arith.constant 0 : index
    %c1_i32 = arith.constant 1 : i32
    %c0_i32 = arith.constant 0 : i32
    %c2_i32 = arith.constant 2 : i32
    %0 = arith.index_cast %arg2 : i32 to index
    %1 = arith.index_cast %arg3 : i32 to index
    %2 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [0, 0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
    %3 = builtin.unrealized_conversion_cast %2 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
    %4 = arith.muli %arg3, %c2_i32 : i32
    %5 = arith.index_cast %4 : i32 to index
    %6:3 = scf.for %arg4 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg5 = %c0, %arg6 = %3, %arg7 = %c0) -> (index, tensor<2x2xi64>, index)  : i32 {
      %7 = scf.for %arg8 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg9 = %arg5) -> (index)  : i32 {
        %10 = arith.addi %arg9, %5 : index
        scf.yield %10 : index
      }
      %8:3 = scf.for %arg8 = %c0_i32 to %c2_i32 step %c1_i32 iter_args(%arg9 = %7, %arg10 = %arg6, %arg11 = %arg7) -> (index, tensor<2x2xi64>, index)  : i32 {
        %10 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg11, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %11 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%arg9, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %12 = "tts.load"(%11) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
        %13 = arith.addi %arg9, %5 : index
        %14 = tts.make_tptr %arg0 to sizes: [2, 2], strides: [%0, %1], offsets: [%13, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %15 = "tts.load"(%14) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>) -> tensor<2x2xf32>
        "tts.store"(%10, %12) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
        %16 = arith.addi %arg11, %5 : index
        %17 = arith.addi %16, %5 : index
        %18 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%17, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        "tts.store"(%18, %15) <{static_mask_dims = array<i64>}> : (tensor<2x2x!tt.ptr<f32>>, tensor<2x2xf32>) -> ()
        %19 = arith.addi %17, %5 : index
        %20 = tts.make_tptr %arg1 to sizes: [2, 2], strides: [%0, %1], offsets: [%19, %c0], shape: [0, 0], order: [] : <f32> to tensor<2x2x!tt.ptr<f32>>
        %21 = builtin.unrealized_conversion_cast %20 : tensor<2x2x!tt.ptr<f32>> to tensor<2x2xi64>
        %22 = arith.addi %13, %5 : index
        scf.yield %22, %21, %19 : index, tensor<2x2xi64>, index
      }
      %9 = arith.addi %8#0, %5 : index
      scf.yield %9, %8#1, %8#2 : index, tensor<2x2xi64>, index
    }
    tt.return
  }
}
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/nested_loops.mlir

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_loop.mlir (67 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_loop.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --canonicalize --triton-arith-to-linalg --structured-to-memref /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --canonicalize --triton-arith-to-linalg --structured-to-memref /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop.mlir
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop.mlir:4:32: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func @reduce_kernel_2d_0d(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: i32, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32) {
                               ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop.mlir:4:32: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xf32>) -> !tt.ptr<f32>
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop.mlir:8:10: note: see existing live user here: 
%1 = scf.for %arg13 = %c0_i32 to %c8_i32 step %c1_i32 iter_args(%arg14 = %0) -> (!tt.ptr<f32>)  : i32 {
  %2 = arith.sitofp %arg13 : i32 to f32
  tt.store %arg14, %2 : !tt.ptr<f32>
  %3 = tt.addptr %arg14, %c1_i32 : !tt.ptr<f32>, i32
  scf.yield %3 : !tt.ptr<f32>
}
    %0 = scf.for %arg7 = %c0_i32 to %c8_i32 step %c1_i32 iter_args(%arg8 = %arg0) -> (!tt.ptr<f32>)  : i32 {
         ^
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_loop.mlir

--

********************
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/get_num_programs.mlir (68 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_nested_loop.mlir (69 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_nested_loop.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --canonicalize --triton-arith-to-linalg --structured-to-memref /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_nested_loop.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_nested_loop.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --canonicalize --triton-arith-to-linalg --structured-to-memref /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_nested_loop.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_nested_loop.mlir
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_nested_loop.mlir:4:32: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func @reduce_kernel_2d_0d(%arg0: !tt.ptr<f32> {tt.divisibility = 16 : i32}, %arg1: i32, %arg2: i32, %arg3: i32, %arg4: i32, %arg5: i32, %arg6: i32) {
                               ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_nested_loop.mlir:4:32: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xf32>) -> !tt.ptr<f32>
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_nested_loop.mlir:9:10: note: see existing live user here: %1 = tt.addptr %0, %arg4 : !tt.ptr<f32>, i32
    %0 = tt.addptr %arg0, %arg4 : !tt.ptr<f32>, i32
         ^
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/scalar_store_nested_loop.mlir

--

********************
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/early_return.mlir (70 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/early_return.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir:19:10: remark: PtrAnalysis: scalar loadOp will not be rewritten
    %2 = tt.load %1 : !tt.ptr<f32>
         ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir:19:10: note: see current operation: %3 = tt.load %2 : !tt.ptr<f32>
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir:19:10: remark: PtrAnalysis: Failed to rewrite LoadOp
    %2 = tt.load %1 : !tt.ptr<f32>
         ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir:19:10: note: see current operation: %3 = tt.load %2 : !tt.ptr<f32>
%4 = unrealized_conversion_cast %3 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
module {
  tt.func public @test_1(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>) attributes {noinline = false} {
    %c0_i64 = arith.constant 0 : i64
    %cst = arith.constant -1.000000e+00 : f32
    %cst_0 = arith.constant dense<1> : tensor<4xi32>
    %0 = tt.get_program_id x : i32
    %1 = arith.extsi %0 : i32 to i64
    %2 = arith.addi %c0_i64, %1 : i64
    %3 = "tts.create_ptr"(%arg0, %2) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
    %4 = builtin.unrealized_conversion_cast %2 : i64 to !tt.ptr<f32> {"reconvert-offset-to-ptr"}
    %5 = tt.load %3 : !tt.ptr<f32>
    %6 = arith.cmpf oeq, %5, %cst : f32
    cf.cond_br %6, ^bb1, ^bb2
  ^bb1:  // pred: ^bb0
    tt.return
  ^bb2:  // pred: ^bb0
    %7 = tt.make_range {end = 4 : i32, start = 0 : i32} : tensor<4xi32>
    %8 = arith.addi %7, %cst_0 : tensor<4xi32>
    %9 = tts.make_tptr %arg1 to sizes: [4], strides: [1], offsets: [0], shape: [0], order: [] : <f32> to tensor<4x!tt.ptr<f32>>
    %10 = arith.sitofp %8 : tensor<4xi32> to tensor<4xf32>
    "tts.store"(%9, %10) <{static_mask_dims = array<i64>}> : (tensor<4x!tt.ptr<f32>>, tensor<4xf32>) -> ()
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 1
ok case
%1 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir:14:26: error: failed to legalize unresolved materialization from ('memref<*xf32>') to '!tt.ptr<f32>' that remained live after conversion
  tt.func public @test_1(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>) attributes {noinline = false} {
                         ^
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir:14:26: note: see current operation: %0 = "builtin.unrealized_conversion_cast"(%arg0) : (memref<*xf32>) -> !tt.ptr<f32>
/home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir:18:10: note: see existing live user here: %4 = "tts.create_ptr"(%0, %3) : (!tt.ptr<f32>, i64) -> !tt.ptr<f32>
    %1 = tt.addptr %arg0, %0 : !tt.ptr<f32>, i32
         ^
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/early_return.mlir

--

********************
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/wraparound_side_by_side.mlir (71 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir (72 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir:1 offset :27:9: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
        tt.store %c, %res0 : tensor<128x128x!tt.ptr<f32>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir:1 offset :27:9: note: see current operation: tt.store %arg2, %15 : tensor<128x128x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir:1 offset :27:9: remark: PtrAnalysis: Failed to rewrite StoreOp
        tt.store %c, %res0 : tensor<128x128x!tt.ptr<f32>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir:1 offset :27:9: note: see current operation: tt.store %arg2, %15 : tensor<128x128x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir:1 offset :28:9: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
        tt.store %d, %res1 : tensor<128x128x!tt.ptr<f32>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir:1 offset :28:9: note: see current operation: tt.store %arg3, %16 : tensor<128x128x!tt.ptr<f32>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir:1 offset :28:9: remark: PtrAnalysis: Failed to rewrite StoreOp
        tt.store %d, %res1 : tensor<128x128x!tt.ptr<f32>>
        ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir:1 offset :28:9: note: see current operation: tt.store %arg3, %16 : tensor<128x128x!tt.ptr<f32>>
module {
  tt.func @kernel(%arg0: !tt.ptr<f32>, %arg1: !tt.ptr<f32>, %arg2: tensor<128x128x!tt.ptr<f32>>, %arg3: tensor<128x128x!tt.ptr<f32>>) {
    %0 = tts.make_tptr %arg0 to sizes: [128, 128], strides: [1, 1], offsets: [0, 0], shape: [0, 0], order: [] : <f32> to tensor<128x128x!tt.ptr<f32>>
    %1 = tts.make_tptr %arg1 to sizes: [128, 128], strides: [1, 1], offsets: [0, 0], shape: [0, 0], order: [] : <f32> to tensor<128x128x!tt.ptr<f32>>
    %2 = "tts.load"(%0) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<128x128x!tt.ptr<f32>>) -> tensor<128x128xf32>
    %3 = "tts.load"(%1) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<128x128x!tt.ptr<f32>>) -> tensor<128x128xf32>
    %4 = arith.addf %2, %3 : tensor<128x128xf32>
    %5 = arith.subf %2, %3 : tensor<128x128xf32>
    tt.store %arg2, %4 : tensor<128x128x!tt.ptr<f32>>
    tt.store %arg3, %5 : tensor<128x128x!tt.ptr<f32>>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg1 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 1
ok case
%1 = unrealized_conversion_cast %arg0 : memref<*xf32> to !tt.ptr<f32>
<block argument> of type 'memref<*xf32>' at index: 0
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir
 #0 0x00005590bca128c7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255c8c7)
 #1 0x00005590bca103ee llvm::sys::RunSignalHandlers() (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255a3ee)
 #2 0x00005590bca12f7f SignalHandler(int) Signals.cpp:0:0
 #3 0x00007f261ce2b420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)
 #4 0x00005590baa5b5d4 mlir::Operation::getResults() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:411:12
 #5 0x00005590baa5b5d4 mlir::Operation::getResultTypes() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:423:47
 #6 0x00005590baa5b5d4 (anonymous namespace)::StoreOpConverter::matchAndRewrite(mlir::triton::StoreOp, mlir::triton::StoreOpAdaptor, mlir::ConversionPatternRewriter&) const /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:306:24
 #7 0x00005590ba97681f mlir::OpConversionPattern<mlir::triton::StoreOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/Transforms/DialectConversion.h:545:3
 #8 0x00005590bc6227c0 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c7c0)
 #9 0x00005590bc6675eb mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_2::operator()() const PatternApplicator.cpp:0:0
#10 0x00005590bc66416f mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21ae16f)
#11 0x00005590bc623751 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0
#12 0x00005590bc622864 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c864)
#13 0x00005590bc623c6f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216dc6f)
#14 0x00005590bc62a3ab mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21743ab)
#15 0x00005590baa59d9d (anonymous namespace)::TritonLoadStoreToMemrefPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:410:16
#16 0x00005590bbf7d336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#17 0x00005590bbf7dae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#18 0x00005590bbf8202f llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (mlir::OpPassManager&, mlir::Operation*)>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_6>(long, mlir::OpPassManager&, mlir::Operation*) Pass.cpp:0:0
#19 0x00005590baa37ac5 llvm::LogicalResult::failed() const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:43:43
#20 0x00005590baa37ac5 llvm::failed(llvm::LogicalResult) /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:71:58
#21 0x00005590baa37ac5 (anonymous namespace)::TritonToLinalgExperimentalPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonToLinalgExperimental/TritonToLinalgExperimentalPass.cpp:63:9
#22 0x00005590bbf7d336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#23 0x00005590bbf7dae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#24 0x00005590bbf7ff95 mlir::PassManager::run(mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac9f95)
#25 0x00005590bbf7966f performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0
#26 0x00005590bbf7929d llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_2>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0
#27 0x00005590bc9a5f74 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef)::$_0::operator()(llvm::StringRef) const ToolUtilities.cpp:0:0
#28 0x00005590bc9a5b50 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x24efb50)
#29 0x00005590bbf740c1 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe0c1)
#30 0x00005590bbf74373 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe373)
#31 0x00005590bbf74746 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe746)
#32 0x00005590baa85d9b main /home/nhat/github/triton_shared/tools/triton-shared-opt/triton-shared-opt.cpp:16:33
#33 0x00007f261c8cf083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3
#34 0x00005590ba74892e _start (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x29292e)
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir

--

********************
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/dot.mlir (73 of 215)
XFAIL: TRITON-SHARED :: Conversion/StructuredToMemref/wraparound_unsupported_add_offset.mlir (74 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/triton-to-structured-prepass.mlir (75 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/kernel-05-layer-norm-fwd.mlir (76 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/block_ptr_advance.mlir (77 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_extern_elementwise.mlir (78 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/ridiculously_nested_loops.mlir (79 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_extern_elementwise.mlir (80 of 215)
FAIL: TRITON-SHARED :: Conversion/StructuredToMemref/reducesum_middle_dim.mlir (81 of 215)
******************** TEST 'TRITON-SHARED :: Conversion/StructuredToMemref/reducesum_middle_dim.mlir' FAILED ********************
Exit Code: 2

Command Output (stderr):
--
RUN: at line 1: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_middle_dim.mlir | FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_middle_dim.mlir
+ /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_middle_dim.mlir
+ FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_middle_dim.mlir
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_middle_dim.mlir:1 offset :37:5: remark: PtrAnalysis: pointer is not replace with tts.make_tptr so storeOp cannot be rewritten
    tt.store %out, %5 : tensor<32x16x!tt.ptr<bf16>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_middle_dim.mlir:1 offset :37:5: note: see current operation: tt.store %arg2, %19 : tensor<32x16x!tt.ptr<bf16>>
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_middle_dim.mlir:1 offset :37:5: remark: PtrAnalysis: Failed to rewrite StoreOp
    tt.store %out, %5 : tensor<32x16x!tt.ptr<bf16>>
    ^
within split at /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_middle_dim.mlir:1 offset :37:5: note: see current operation: tt.store %arg2, %19 : tensor<32x16x!tt.ptr<bf16>>
module {
  tt.func @kernel(%arg0: !tt.ptr<bf16>, %arg1: !tt.ptr<bf16>, %arg2: tensor<32x16x!tt.ptr<bf16>>) {
    %c256 = arith.constant 256 : index
    %0 = tts.make_tptr %arg0 to sizes: [32, 256, 16], strides: [%c256, 1, 1], offsets: [0, 0, 0], shape: [0, 0, 0], order: [] : <bf16> to tensor<32x256x16x!tt.ptr<bf16>>
    %1 = "tts.load"(%0) <{operandSegmentSizes = array<i32: 1, 0, 0>, static_mask_dims = array<i64>}> : (tensor<32x256x16x!tt.ptr<bf16>>) -> tensor<32x256x16xbf16>
    %2 = "tt.reduce"(%1) <{axis = 1 : i32}> ({
    ^bb0(%arg3: bf16, %arg4: bf16):
      %3 = arith.addf %arg3, %arg4 : bf16
      tt.reduce.return %3 : bf16
    }) : (tensor<32x256x16xbf16>) -> tensor<32x16xbf16>
    tt.store %arg2, %2 : tensor<32x16x!tt.ptr<bf16>>
    tt.return
  }
}
ok case
%0 = unrealized_conversion_cast %arg0 : memref<*xbf16> to !tt.ptr<bf16>
<block argument> of type 'memref<*xbf16>' at index: 0
PLEASE submit a bug report to https://github.com/llvm/llvm-project/issues/ and include the crash backtrace.
Stack dump:
0.	Program arguments: /home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt --split-input-file --triton-to-linalg-experimental /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_middle_dim.mlir
 #0 0x000055ebdbd488c7 llvm::sys::PrintStackTrace(llvm::raw_ostream&, int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255c8c7)
 #1 0x000055ebdbd463ee llvm::sys::RunSignalHandlers() (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x255a3ee)
 #2 0x000055ebdbd48f7f SignalHandler(int) Signals.cpp:0:0
 #3 0x00007f304b37e420 __restore_rt (/lib/x86_64-linux-gnu/libpthread.so.0+0x14420)
 #4 0x000055ebd9d915d4 mlir::Operation::getResults() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:411:12
 #5 0x000055ebd9d915d4 mlir::Operation::getResultTypes() /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/IR/Operation.h:423:47
 #6 0x000055ebd9d915d4 (anonymous namespace)::StoreOpConverter::matchAndRewrite(mlir::triton::StoreOp, mlir::triton::StoreOpAdaptor, mlir::ConversionPatternRewriter&) const /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:306:24
 #7 0x000055ebd9cac81f mlir::OpConversionPattern<mlir::triton::StoreOp>::matchAndRewrite(mlir::Operation*, llvm::ArrayRef<mlir::Value>, mlir::ConversionPatternRewriter&) const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/mlir/Transforms/DialectConversion.h:545:3
 #8 0x000055ebdb9587c0 mlir::ConversionPattern::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&) const (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c7c0)
 #9 0x000055ebdb99d5eb mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>)::$_2::operator()() const PatternApplicator.cpp:0:0
#10 0x000055ebdb99a16f mlir::PatternApplicator::matchAndRewrite(mlir::Operation*, mlir::PatternRewriter&, llvm::function_ref<bool (mlir::Pattern const&)>, llvm::function_ref<void (mlir::Pattern const&)>, llvm::function_ref<llvm::LogicalResult (mlir::Pattern const&)>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21ae16f)
#11 0x000055ebdb959751 (anonymous namespace)::OperationLegalizer::legalize(mlir::Operation*, mlir::ConversionPatternRewriter&) DialectConversion.cpp:0:0
#12 0x000055ebdb958864 mlir::OperationConverter::convert(mlir::ConversionPatternRewriter&, mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216c864)
#13 0x000055ebdb959c6f mlir::OperationConverter::convertOperations(llvm::ArrayRef<mlir::Operation*>) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x216dc6f)
#14 0x000055ebdb9603ab mlir::applyPartialConversion(mlir::Operation*, mlir::ConversionTarget const&, mlir::FrozenRewritePatternSet const&, mlir::ConversionConfig) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x21743ab)
#15 0x000055ebd9d8fd9d (anonymous namespace)::TritonLoadStoreToMemrefPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonLoadStoreToMemref/TritonLoadStoreToMemrefPass.cpp:410:16
#16 0x000055ebdb2b3336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#17 0x000055ebdb2b3ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#18 0x000055ebdb2b802f llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (mlir::OpPassManager&, mlir::Operation*)>::callback_fn<mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int)::$_6>(long, mlir::OpPassManager&, mlir::Operation*) Pass.cpp:0:0
#19 0x000055ebd9d6dac5 llvm::LogicalResult::failed() const /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:43:43
#20 0x000055ebd9d6dac5 llvm::failed(llvm::LogicalResult) /home/nhat/.triton/llvm/llvm-c08c6a71-ubuntu-x64/include/llvm/Support/LogicalResult.h:71:58
#21 0x000055ebd9d6dac5 (anonymous namespace)::TritonToLinalgExperimentalPass::runOnOperation() /home/nhat/github/triton_shared/lib/Conversion/TritonToLinalgExperimental/TritonToLinalgExperimentalPass.cpp:63:9
#22 0x000055ebdb2b3336 mlir::detail::OpToOpPassAdaptor::run(mlir::Pass*, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7336)
#23 0x000055ebdb2b3ae0 mlir::detail::OpToOpPassAdaptor::runPipeline(mlir::OpPassManager&, mlir::Operation*, mlir::AnalysisManager, bool, unsigned int, mlir::PassInstrumentor*, mlir::PassInstrumentation::PipelineParentInfo const*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac7ae0)
#24 0x000055ebdb2b5f95 mlir::PassManager::run(mlir::Operation*) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1ac9f95)
#25 0x000055ebdb2af66f performActions(llvm::raw_ostream&, std::shared_ptr<llvm::SourceMgr> const&, mlir::MLIRContext*, mlir::MlirOptMainConfig const&) MlirOptMain.cpp:0:0
#26 0x000055ebdb2af29d llvm::LogicalResult llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>::callback_fn<mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&)::$_2>(long, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&) MlirOptMain.cpp:0:0
#27 0x000055ebdbcdbf74 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef)::$_0::operator()(llvm::StringRef) const ToolUtilities.cpp:0:0
#28 0x000055ebdbcdbb50 mlir::splitAndProcessBuffer(std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::function_ref<llvm::LogicalResult (std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, llvm::raw_ostream&)>, llvm::raw_ostream&, llvm::StringRef, llvm::StringRef) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x24efb50)
#29 0x000055ebdb2aa0c1 mlir::MlirOptMain(llvm::raw_ostream&, std::unique_ptr<llvm::MemoryBuffer, std::default_delete<llvm::MemoryBuffer>>, mlir::DialectRegistry&, mlir::MlirOptMainConfig const&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe0c1)
#30 0x000055ebdb2aa373 mlir::MlirOptMain(int, char**, llvm::StringRef, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe373)
#31 0x000055ebdb2aa746 mlir::MlirOptMain(int, char**, llvm::StringRef, mlir::DialectRegistry&) (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x1abe746)
#32 0x000055ebd9dbbd9b main /home/nhat/github/triton_shared/tools/triton-shared-opt/triton-shared-opt.cpp:16:33
#33 0x00007f304ae22083 __libc_start_main /build/glibc-LcI20x/glibc-2.31/csu/../csu/libc-start.c:342:3
#34 0x000055ebd9a7e92e _start (/home/nhat/github/triton_shared/triton/python/build/cmake.linux-x86_64-cpython-3.8/third_party/triton_shared/tools/triton-shared-opt/triton-shared-opt+0x29292e)
FileCheck error: '<stdin>' is empty.
FileCheck command line:  FileCheck /home/nhat/github/triton_shared/test/Conversion/StructuredToMemref/reducesum_middle_dim.mlir

--

********************
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_scalar_for_2d.mlir (82 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_scalar_loopback.mlir (83 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/wraparound_unsupported_add_offset.mlir (84 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/kernel-01-vector-add.mlir (85 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_for_more_init_args.mlir (86 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/reduce_extend_fp32_precision.mlir (87 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_for_accumulation.mlir (88 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/kernel-02-fused-softmax.mlir (89 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/dot.mlir (90 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_1d_elemwise_arith_binary.mlir (91 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/masked_ldst_sitofp_other.mlir (92 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_tensor_reshape.mlir (93 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/reducesum_middle_dim.mlir (94 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_scalar_splat.mlir (95 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_addi_reduce.mlir (96 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/dot.mlir (97 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/use_dot_opc.mlir (98 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_2d_elemwise_arith_unary.mlir (99 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/reducesum_512_256_f32_axis0.mlir (100 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/use_mid_chain.mlir (101 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_minmax_fp_reduce.mlir (102 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/wraparound_stacked.mlir (103 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/unsupported_extern_elementwise.mlir (104 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_argmin_argmax_2d.mlir (105 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/unsupported_extern_elementwise.mlir (106 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/nested_loops.mlir (107 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_scalar_splat_2d.mlir (108 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/masked_ldst_1d.mlir (109 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/use_end_chain.mlir (110 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_1d_elemwise_arith_unary.mlir (111 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_scalar_broadcast.mlir (112 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/block_ptr_advance.mlir (113 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/reducesum_512_256_f32_axis1.mlir (114 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/use_end_chain.mlir (115 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/sign_extend_i32_to_i64.mlir (116 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/kernel-05-layer-norm-fwd.mlir (117 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/use_dot_opc.mlir (118 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/reducesum_middle_dim.mlir (119 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_1d_elemwise_arith_ternary.mlir (120 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_mul_const_const.mlir (121 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/masked_ldst_2d.mlir (122 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/wraparound_side_by_side.mlir (123 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/kernel-03-matrix-multiplication.mlir (124 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/kernel-01-vector-add.mlir (125 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_argmin_argmax_2d.mlir (126 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_loopback.mlir (127 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/reducesum_512_256_bf16_axis0.mlir (128 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/tensor_indices_loop_iterargs_not_used_ptranalysis_prepass.mlir (129 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_argmin_argmax.mlir (130 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/masked_ldst_1d.mlir (131 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/reducesum_512_256_f32_axis1.mlir (132 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_dim1.mlir (133 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/reducesum_512_256_f32_axis0.mlir (134 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/wraparound_side_by_side.mlir (135 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_2d_elemwise_arith_binary.mlir (136 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_splat_float.mlir (137 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_argmin_argmax.mlir (138 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_scalar_splat_2d.mlir (139 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_reshape_broadcast.mlir (140 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/reducesum_512_256_bf16_axis0.mlir (141 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/early_return.mlir (142 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_nested.mlir (143 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_scalar_nested.mlir (144 of 215)
XFAIL: TRITON-SHARED :: Conversion/TritonToLinalg/wraparound_unsupported_add_offset.mlir (145 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_2d_elemwise_arith_unary.mlir (146 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/make_tensor_ptr_ordering_error.mlir (147 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/reducemax_32_256_bf16.mlir (148 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/bitcast.mlir (149 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/triton_assert.mlir (150 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_for_expand_ptr.mlir (151 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_minmax.mlir (152 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/kernel-05-layer-norm-dwdb.mlir (153 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/tensor_indices_loop_iterargs_nested.mlir (154 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/cumsum.mlir (155 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_for_used_before_update.mlir (156 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_minmax_reduce.mlir (157 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_mul_const_const.mlir (158 of 215)
PASS: TRITON-SHARED :: Conversion/StructuredToMemref/triton_assert.mlir (159 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_for_used_after_update.mlir (160 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/kernel-03-matrix-multiplication.mlir (161 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_splat_float.mlir (162 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_1d_elemwise_arith_binary.mlir (163 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/block_ptr_advance.mlir (164 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_2d_elemwise_arith_binary.mlir (165 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/masked_ldst_sitofp_other.mlir (166 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/masked_ldst_2d.mlir (167 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_minmax_reduce.mlir (168 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_2d_example.mlir (169 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_tensor_reshape.mlir (170 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/reducesum_512_256_bf16_axis1.mlir (171 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_add_value.mlir (172 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/reducemax_32_256_bf16.mlir (173 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/triton_assert.mlir (174 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_addi_reduce.mlir (175 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/wraparound_stacked.mlir (176 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_scalar_for.mlir (177 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/bitcast.mlir (178 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/use_mid_chain.mlir (179 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_nested.mlir (180 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_for_used_after_update.mlir (181 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_for_used_before_update.mlir (182 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_for_more_init_args.mlir (183 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_scalar_for.mlir (184 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/reducesum_scalar.mlir (185 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/cumsum.mlir (186 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_for_accumulation.mlir (187 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_add_value.mlir (188 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/kernel-02-fused-softmax.mlir (189 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/arith_not_ptr_arith.mlir (190 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/bitcast.mlir (191 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_2d_elemwise_arith_ternary.mlir (192 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_2d_example.mlir (193 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_scalar_for_2d.mlir (194 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_for_expand_ptr.mlir (195 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/tensor_indices_loop_iterargs_not_used_ptranalysis_e2e.mlir (196 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_1d_elemwise_arith_unary.mlir (197 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/arith_not_ptr_arith.mlir (198 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_scalar_splat.mlir (199 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_loopback.mlir (200 of 215)
XFAIL: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_dim1.mlir (201 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/kernel-05-layer-norm-dwdb.mlir (202 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_reshape_broadcast.mlir (203 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_mul_value_const.mlir (204 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_2d_elemwise_arith_ternary.mlir (205 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/reducesum_512_256_bf16_axis1.mlir (206 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_scalar_nested.mlir (207 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/addptr_scalar_loopback.mlir (208 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_scalar_broadcast.mlir (209 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/convert_1d_elemwise_arith_ternary.mlir (210 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/tensor_indices_loop_iterarg_with_masks.mlir (211 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToStructured/addptr_mul_value_const.mlir (212 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/reducesum_scalar.mlir (213 of 215)
PASS: TRITON-SHARED :: Conversion/TritonToLinalg/get_num_programs.mlir (214 of 215)
PASS: TRITON-SHARED :: Conversion/TritonArithToLinalg/convert_minmax_fp_reduce.mlir (215 of 215)
********************
Failed Tests (28):
  TRITON-SHARED :: Conversion/StructuredToMemref/addptr_chain.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_for.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_for_2d.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/addptr_scalar_loopback.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/block_ptr_complex_offset.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_1d_elemwise_arith_binary.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_1d_elemwise_arith_ternary.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_1d_elemwise_arith_unary.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_2d_elemwise_arith_binary.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_2d_elemwise_arith_ternary.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_2d_elemwise_arith_unary.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_addi_reduce.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_argmin_argmax.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_minmax.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_minmax_fp_reduce.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_minmax_reduce.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/convert_splat_float.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/early_return.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/kernel-05-layer-norm-fwd.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/nested_loops.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/reducemax_32_256_bf16.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/reducesum_middle_dim.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/reducesum_scalar.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/ridiculously_nested_loops.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_loop.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_loop_iterargs.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_nested_loop.mlir
  TRITON-SHARED :: Conversion/StructuredToMemref/scalar_store_no_iterargs.mlir


Testing Time: 5.07s

Total Discovered Tests: 215
  Passed           : 184 (85.58%)
  Expectedly Failed:   3 (1.40%)
  Failed           :  28 (13.02%)
