; ModuleID = 'LLVMDialectModule'
source_filename = "LLVMDialectModule"

declare void @memrefCopy(i64, ptr, ptr)

declare ptr @malloc(i64)

define void @add_kernel_0d1d2d3de(i64 %0, ptr %1, i64 %2, ptr %3, i64 %4, ptr %5, i32 %6, i32 %7, i32 %8, i32 %9, i32 %10, i32 %11, i32 %12) {
  %14 = insertvalue { i64, ptr } undef, i64 %0, 0
  %15 = insertvalue { i64, ptr } %14, ptr %1, 1
  %16 = insertvalue { i64, ptr } undef, i64 %2, 0
  %17 = insertvalue { i64, ptr } %16, ptr %3, 1
  %18 = insertvalue { i64, ptr } undef, i64 %4, 0
  %19 = insertvalue { i64, ptr } %18, ptr %5, 1
  %20 = mul i32 %10, 1024
  %21 = sext i32 %20 to i64
  %22 = load ptr, ptr %1, align 8
  %23 = getelementptr ptr, ptr %1, i32 1
  %24 = load ptr, ptr %23, align 8
  %25 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %22, 0
  %26 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %25, ptr %24, 1
  %27 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %26, i64 %21, 2
  %28 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %27, i64 1024, 3, 0
  %29 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %28, i64 1, 4, 0
  %30 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (float, ptr null, i32 1024) to i64))
  %31 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %30, 0
  %32 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %31, ptr %30, 1
  %33 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %32, i64 0, 2
  %34 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %33, i64 1024, 3, 0
  %35 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %34, i64 1, 4, 0
  %36 = sext i32 %20 to i64
  %37 = add i64 %36, 1024
  %38 = sext i32 %6 to i64
  %39 = call i64 @llvm.smin.i64(i64 %37, i64 %38)
  %40 = sub i64 %39, %36
  %41 = insertvalue { ptr, ptr, i64 } undef, ptr %22, 0
  %42 = insertvalue { ptr, ptr, i64 } %41, ptr %24, 1
  %43 = insertvalue { ptr, ptr, i64 } %42, i64 0, 2
  %44 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %22, 0
  %45 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %44, ptr %24, 1
  %46 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %45, i64 %21, 2
  %47 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %46, i64 %40, 3, 0
  %48 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %47, i64 1, 4, 0
  %49 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %30, 0
  %50 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %49, ptr %30, 1
  %51 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %50, i64 0, 2
  %52 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %51, i64 %40, 3, 0
  %53 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %52, i64 1, 4, 0
  %54 = call ptr @llvm.stacksave.p0()
  %55 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %48, ptr %55, align 8
  %56 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %55, 1
  %57 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %53, ptr %57, align 8
  %58 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %57, 1
  %59 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %56, ptr %59, align 8
  %60 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %58, ptr %60, align 8
  call void @memrefCopy(i64 ptrtoint (ptr getelementptr (float, ptr null, i32 1) to i64), ptr %59, ptr %60)
  call void @llvm.stackrestore.p0(ptr %54)
  %61 = sext i32 %20 to i64
  %62 = load ptr, ptr %3, align 8
  %63 = getelementptr ptr, ptr %3, i32 1
  %64 = load ptr, ptr %63, align 8
  %65 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %62, 0
  %66 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %65, ptr %64, 1
  %67 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %66, i64 %61, 2
  %68 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %67, i64 1024, 3, 0
  %69 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %68, i64 1, 4, 0
  %70 = call ptr @malloc(i64 ptrtoint (ptr getelementptr (float, ptr null, i32 1024) to i64))
  %71 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %70, 0
  %72 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %71, ptr %70, 1
  %73 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %72, i64 0, 2
  %74 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %73, i64 1024, 3, 0
  %75 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %74, i64 1, 4, 0
  %76 = sext i32 %20 to i64
  %77 = add i64 %76, 1024
  %78 = sext i32 %6 to i64
  %79 = call i64 @llvm.smin.i64(i64 %77, i64 %78)
  %80 = sub i64 %79, %76
  %81 = insertvalue { ptr, ptr, i64 } undef, ptr %62, 0
  %82 = insertvalue { ptr, ptr, i64 } %81, ptr %64, 1
  %83 = insertvalue { ptr, ptr, i64 } %82, i64 0, 2
  %84 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %62, 0
  %85 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %84, ptr %64, 1
  %86 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %85, i64 %61, 2
  %87 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %86, i64 %80, 3, 0
  %88 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %87, i64 1, 4, 0
  %89 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %70, 0
  %90 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %89, ptr %70, 1
  %91 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %90, i64 0, 2
  %92 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %91, i64 %80, 3, 0
  %93 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %92, i64 1, 4, 0
  %94 = call ptr @llvm.stacksave.p0()
  %95 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %88, ptr %95, align 8
  %96 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %95, 1
  %97 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %93, ptr %97, align 8
  %98 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %97, 1
  %99 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %96, ptr %99, align 8
  %100 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %98, ptr %100, align 8
  call void @memrefCopy(i64 ptrtoint (ptr getelementptr (float, ptr null, i32 1) to i64), ptr %99, ptr %100)
  call void @llvm.stackrestore.p0(ptr %94)
  br label %101

101:                                              ; preds = %104, %13
  %102 = phi i64 [ %111, %104 ], [ 0, %13 ]
  %103 = icmp slt i64 %102, 1024
  br i1 %103, label %104, label %112

104:                                              ; preds = %101
  %105 = getelementptr float, ptr %30, i64 %102
  %106 = load float, ptr %105, align 4
  %107 = getelementptr float, ptr %70, i64 %102
  %108 = load float, ptr %107, align 4
  %109 = fadd float %106, %108
  %110 = getelementptr float, ptr %30, i64 %102
  store float %109, ptr %110, align 4
  %111 = add i64 %102, 1
  br label %101

112:                                              ; preds = %101
  %113 = sext i32 %20 to i64
  %114 = load ptr, ptr %5, align 8
  %115 = getelementptr ptr, ptr %5, i32 1
  %116 = load ptr, ptr %115, align 8
  %117 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %114, 0
  %118 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %117, ptr %116, 1
  %119 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %118, i64 %113, 2
  %120 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %119, i64 1024, 3, 0
  %121 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %120, i64 1, 4, 0
  %122 = sext i32 %20 to i64
  %123 = add i64 %122, 1024
  %124 = sext i32 %6 to i64
  %125 = call i64 @llvm.smin.i64(i64 %123, i64 %124)
  %126 = sub i64 %125, %122
  %127 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %30, 0
  %128 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %127, ptr %30, 1
  %129 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %128, i64 0, 2
  %130 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %129, i64 %126, 3, 0
  %131 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %130, i64 1, 4, 0
  %132 = insertvalue { ptr, ptr, i64 } undef, ptr %114, 0
  %133 = insertvalue { ptr, ptr, i64 } %132, ptr %116, 1
  %134 = insertvalue { ptr, ptr, i64 } %133, i64 0, 2
  %135 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } undef, ptr %114, 0
  %136 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %135, ptr %116, 1
  %137 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %136, i64 %113, 2
  %138 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %137, i64 %126, 3, 0
  %139 = insertvalue { ptr, ptr, i64, [1 x i64], [1 x i64] } %138, i64 1, 4, 0
  %140 = call ptr @llvm.stacksave.p0()
  %141 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %131, ptr %141, align 8
  %142 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %141, 1
  %143 = alloca { ptr, ptr, i64, [1 x i64], [1 x i64] }, i64 1, align 8
  store { ptr, ptr, i64, [1 x i64], [1 x i64] } %139, ptr %143, align 8
  %144 = insertvalue { i64, ptr } { i64 1, ptr undef }, ptr %143, 1
  %145 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %142, ptr %145, align 8
  %146 = alloca { i64, ptr }, i64 1, align 8
  store { i64, ptr } %144, ptr %146, align 8
  call void @memrefCopy(i64 ptrtoint (ptr getelementptr (float, ptr null, i32 1) to i64), ptr %145, ptr %146)
  call void @llvm.stackrestore.p0(ptr %140)
  ret void
}

; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)
declare i64 @llvm.smin.i64(i64, i64) #0

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare ptr @llvm.stacksave.p0() #1

; Function Attrs: nocallback nofree nosync nounwind willreturn
declare void @llvm.stackrestore.p0(ptr) #1

attributes #0 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }
attributes #1 = { nocallback nofree nosync nounwind willreturn }

!llvm.module.flags = !{!0}

!0 = !{i32 2, !"Debug Info Version", i32 3}
